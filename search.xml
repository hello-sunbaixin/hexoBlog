<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[ajax源码解析-jQuery. ajaxPrefilter和jQuery. ajaxTransport]]></title>
      <url>http://yoursite.com/2016/11/04/ajax_5/</url>
      <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142全局变量var prefilter=&#123;&#125;;jQuery.extend(&#123; ajaxPrefilter: addToPrefiltersOrTransports(prefilters), ajaxTransport: addToPrefiltersOrTransports(transports), &#125;)&lt;!--ajaxPrefilter和ajaxTransport的构造器--&gt;function addToPrefiltersOrTransports(structure) &#123; // dataTypeExpression is optional and defaults to &quot;*&quot; &lt;!--返回的是一个函数 此处应用的就是闭包--&gt; return function (dataTypeExpression, func) &#123; if (typeof dataTypeExpression !== &quot;string&quot;) &#123; func = dataTypeExpression; dataTypeExpression = &quot;*&quot;; &#125; if (jQuery.isFunction(func)) &#123; var dataTypes = dataTypeExpression.toLowerCase().split(rspacesAjax), i = 0, length = dataTypes.length, dataType, list, placeBefore; // For each dataType in the dataTypeExpression for (; i &lt; length; i++) &#123; dataType = dataTypes[i]; // We control if we&apos;re asked to add before // any existing element placeBefore = /^\+/.test(dataType); if (placeBefore) &#123; dataType = dataType.substr(1) || &quot;*&quot;; &#125; list = structure[dataType] = structure[dataType] || []; // then we add to the structure accordingly list[placeBefore ? &quot;unshift&quot; : &quot;push&quot;](func); &#125; &#125; &#125;; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172jQuery.ajaxPrefilter(&quot;script&quot;, function (s) &#123; if (s.cache === undefined) &#123; s.cache = false; &#125; if (s.crossDomain) &#123; s.type = &quot;GET&quot;; s.global = false; &#125; &#125;);jQuery.ajaxPrefilter(&quot;json jsonp&quot;, function (s, originalSettings, jqXHR) &#123; var inspectData = s.contentType === &quot;application/x-www-form-urlencoded&quot; &amp;&amp; ( typeof s.data === &quot;string&quot; ); if (s.dataTypes[0] === &quot;jsonp&quot; || s.jsonp !== false &amp;&amp; ( jsre.test(s.url) || inspectData &amp;&amp; jsre.test(s.data) )) &#123; var responseContainer, jsonpCallback = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback, previous = window[jsonpCallback], url = s.url, data = s.data, replace = &quot;$1&quot; + jsonpCallback + &quot;$2&quot;; if (s.jsonp !== false) &#123; url = url.replace(jsre, replace); if (s.url === url) &#123; if (inspectData) &#123; data = data.replace(jsre, replace); &#125; if (s.data === data) &#123; // Add callback manually url += (/\?/.test(url) ? &quot;&amp;&quot; : &quot;?&quot;) + s.jsonp + &quot;=&quot; + jsonpCallback; &#125; &#125; &#125; s.url = url; s.data = data; // Install callback window[jsonpCallback] = function (response) &#123; responseContainer = [response]; &#125;; // Clean-up function jqXHR.always(function () &#123; // Set callback back to previous value window[jsonpCallback] = previous; // Call if it was a function and we have a response if (responseContainer &amp;&amp; jQuery.isFunction(previous)) &#123; window[jsonpCallback](responseContainer[0]); &#125; &#125;); // Use data converter to retrieve json after script execution s.converters[&quot;script json&quot;] = function () &#123; if (!responseContainer) &#123; jQuery.error(jsonpCallback + &quot; was not called&quot;); &#125; return responseContainer[0]; &#125;; // force json dataType s.dataTypes[0] = &quot;json&quot;; // Delegate to script return &quot;script&quot;; &#125; &#125;); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227&lt;!--处理跨域情况的--&gt; jQuery.ajaxTransport(&quot;script&quot;, function (s) &#123; // This transport only deals with cross domain requests if (s.crossDomain) &#123; var script, head = document.head || document.getElementsByTagName(&quot;head&quot;)[0] || document.documentElement; return &#123; send: function (_, callback) &#123; script = document.createElement(&quot;script&quot;); script.async = &quot;async&quot;; if (s.scriptCharset) &#123; script.charset = s.scriptCharset; &#125; script.src = s.url; // Attach handlers for all browsers script.onload = script.onreadystatechange = function (_, isAbort) &#123; if (isAbort || !script.readyState || /loaded|complete/.test(script.readyState)) &#123; // Handle memory leak in IE script.onload = script.onreadystatechange = null; // Remove the script if (head &amp;&amp; script.parentNode) &#123; head.removeChild(script); &#125; // Dereference the script script = undefined; // Callback if not abort if (!isAbort) &#123; callback(200, &quot;success&quot;); &#125; &#125; &#125;; // Use insertBefore instead of appendChild to circumvent an IE6 bug. // This arises when a base node is used (#2709 and #4378). head.insertBefore(script, head.firstChild); &#125;, abort: function () &#123; if (script) &#123; script.onload(0, 1); &#125; &#125; &#125;; &#125; &#125;); &lt;!--处理xmlHttpRequest请求--&gt; if (jQuery.support.ajax) &#123; jQuery.ajaxTransport(function (s) &#123; // Cross domain only allowed if supported through XMLHttpRequest if (!s.crossDomain || jQuery.support.cors) &#123; var callback; return &#123; send: function (headers, complete) &#123; // Get a new xhr var xhr = s.xhr(), handle, i; // Open the socket // Passing null username, generates a login popup on Opera (#2865) if (s.username) &#123; xhr.open(s.type, s.url, s.async, s.username, s.password); &#125; else &#123; xhr.open(s.type, s.url, s.async); &#125; // Apply custom fields if provided if (s.xhrFields) &#123; for (i in s.xhrFields) &#123; xhr[i] = s.xhrFields[i]; &#125; &#125; // Override mime type if needed if (s.mimeType &amp;&amp; xhr.overrideMimeType) &#123; xhr.overrideMimeType(s.mimeType); &#125; // X-Requested-With header // For cross-domain requests, seeing as conditions for a preflight are // akin to a jigsaw puzzle, we simply never set it to be sure. // (it can always be set on a per-request basis or even using ajaxSetup) // For same-domain requests, won&apos;t change header if already provided. if (!s.crossDomain &amp;&amp; !headers[&quot;X-Requested-With&quot;]) &#123; headers[&quot;X-Requested-With&quot;] = &quot;XMLHttpRequest&quot;; &#125; // Need an extra try/catch for cross domain requests in Firefox 3 try &#123; for (i in headers) &#123; xhr.setRequestHeader(i, headers[i]); &#125; &#125; catch (_) &#123; &#125; // Do send the request // This may raise an exception which is actually // handled in jQuery.ajax (so no try/catch here) xhr.send(( s.hasContent &amp;&amp; s.data ) || null); // Listener callback = function (_, isAbort) &#123; var status, statusText, responseHeaders, responses, xml; // Firefox throws exceptions when accessing properties // of an xhr when a network error occured // http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE) try &#123; // Was never called and is aborted or complete if (callback &amp;&amp; ( isAbort || xhr.readyState === 4 )) &#123; // Only called once callback = undefined; // Do not keep as active anymore if (handle) &#123; xhr.onreadystatechange = jQuery.noop; if (xhrOnUnloadAbort) &#123; delete xhrCallbacks[handle]; &#125; &#125; // If it&apos;s an abort if (isAbort) &#123; // Abort it manually if needed if (xhr.readyState !== 4) &#123; xhr.abort(); &#125; &#125; else &#123; status = xhr.status; responseHeaders = xhr.getAllResponseHeaders(); responses = &#123;&#125;; xml = xhr.responseXML; // Construct response list if (xml &amp;&amp; xml.documentElement /* #4958 */) &#123; responses.xml = xml; &#125; responses.text = xhr.responseText; // Firefox throws an exception when accessing // statusText for faulty cross-domain requests try &#123; statusText = xhr.statusText; &#125; catch (e) &#123; // We normalize with Webkit giving an empty statusText statusText = &quot;&quot;; &#125; // Filter status for non standard behaviors // If the request is local and we have data: assume a success // (success with no data won&apos;t get notified, that&apos;s the best we // can do given current implementations) if (!status &amp;&amp; s.isLocal &amp;&amp; !s.crossDomain) &#123; status = responses.text ? 200 : 404; // IE - #1450: sometimes returns 1223 when it should be 204 &#125; else if (status === 1223) &#123; status = 204; &#125; &#125; &#125; &#125; catch (firefoxAccessException) &#123; if (!isAbort) &#123; complete(-1, firefoxAccessException); &#125; &#125; // Call complete if needed if (responses) &#123; complete(status, statusText, responses, responseHeaders); &#125; &#125;; // if we&apos;re in sync mode or it&apos;s in cache // and has been retrieved directly (IE6 &amp; IE7) // we need to manually fire the callback if (!s.async || xhr.readyState === 4) &#123; callback(); &#125; else &#123; handle = ++xhrId; if (xhrOnUnloadAbort) &#123; // Create the active xhrs callbacks list if needed // and attach the unload handler if (!xhrCallbacks) &#123; xhrCallbacks = &#123;&#125;; jQuery(window).unload(xhrOnUnloadAbort); &#125; // Add to list of active xhrs callbacks xhrCallbacks[handle] = callback; &#125; xhr.onreadystatechange = callback; &#125; &#125;, abort: function () &#123; if (callback) &#123; callback(0, 1); &#125; &#125; &#125;; &#125; &#125;); &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ajax源码解析-$.ajax()中常见应用示例]]></title>
      <url>http://yoursite.com/2016/11/03/ajax_4/</url>
      <content type="text"><![CDATA[$.ajax()中常见应用示例 cache和ifModified参数 跨域请求 cache和ifModified参数1) cache参数：GET和POST最重要的区别（传送门）语义上，GET是获取指定URL上的资源，是读操作，重要的一点是不论对某个资源GET多少次，它的状态是不会改变的，在这个意义上，我们说GET是安全的（不是被密码学或者数据保护意义上的安全）。因为GET是安全的，所以GET返回的内容可以被浏览器，Cache服务器缓存起来。而POST的语意是对指定资源“追加/添加”数据，所以是不安全的，每次提交的POST，参与的代码都会认为这个操作会修改操作对象资源的状态，于是，浏览器在你按下F5的时候会跳出确认框，缓存服务器不会缓存POST请求返回内容。2) ifModified参数：通过ifModified参数提高请求性能（即：“条件GET”：Last-Modified / If-Modified-Since和ETag / If-None-Match）当你请求的资源并不是一层不变的时候，即不能简单的一直使用客户端缓存时，你可能通过将cache设置为false来发送请求，这实际上是在url加上时间戳组合成新的url，每次发送新的请求，这明显加大了服务器的压力。对于这种情况，我们可以通过ifModified参数改进缓存方式（即：cache和ifModified都设置为true），仅在请求的数据改变时重新获取。通过这种方式请求的url不会改变，并且每次都会发送到服务器，只是会有检验方法验证是否需要重新获取数据从而节省带宽和开销。更多ETag描述（优点，解决了Last-Modified无法解决的一些问题，什么场合不应该被使用） 过程如下：a) 将$.ajax()函数的cache和ifModified参数同时设置为true。b) 客户端请求服务端A，在服务端加上Last-Modified/ETag响应体一起返回。c) 客户端缓存接收到的Last-Modified/ETag响应体，并在下一次发生请求A时将缓存的Last-Modified/ETag值做为If-Modified-Since/IF-None-Match请求头一起发给服务器。d) 服务器接收If-Modified-Since/IF-None-Match后，就根据参数值检验自上次客服端请求之后资源是否有改动 i. 若还未改动则直接返回响应304和一个空的响应体。 ii. 若已改动则重新处理数据，返回最新的请求数据。e) 这样，既保证不向客户端重复发出资源，也保证当服务器有变化时，客户端能够得到最新的资源。这一过程中，我们只需要做：服务器返回Last-Modified/ETag响应头和在服务端检验数据是否失效并采取对应处理方式。其余步骤由jQuery框架的ajax()函数完成。 关键代码如下：客服端：1234567891011121314 $(&apos;#btn_nowTime_long3&apos;).bind(&apos;click&apos;, null , function () &#123; $.ajax(&apos;AjaxHandler.ashx?func=GetServerTime4Modified&apos;, &#123; type: &apos;get&apos;, dataType: &apos;text&apos;, cache: true, ifModified: true, success: function (data) &#123; if (data) alert(data); &#125;, &#125;);&#125;); 服务端： 123456789101112131415if(!String.IsNullOrEmpty(context.Request.Headers[&quot;If-Modified-Since&quot;]))&#123; if (CheckResourceValidate()) // 检查资源有效性 &#123; // 如果资源有效，则直接返回304状态码，客户端回去到此状态码后会从缓存中取值。 context.Response.StatusCode = 304; return; &#125;&#125; // 请求数据GetServerTimeAfter2Second();context.Response.Cache.SetExpires(DateTime.Now.AddSeconds(5));// 设置Last-Modified响应体context.Response.Cache.SetLastModified(DateTime.Now); 跨域请求在JavaScript中，有一个很重要的安全性限制，被称为“Same-Origin Policy”（同源策略）。这一策略对于JavaScript代码能够访问的页面内容做了很重要的限制，即JavaScript只能访问与包含它的文档在同一域下的内容。所谓同源是指，域名(host)，协议(protocol)，端口(port)相同。 URL 说明 是否允许通信 能否通过javascript解决 http://www.a.com/a.js http://www.a.com/b.js 同一域名下 允许 http://www.a.com/lab/a.js http://www.a.com/script/b.js 同一域名下不同文件夹 允许 http://www.a.com:8000/a.js http://www.a.com/b.js 同一域名，不同端口 不允许 能 http://www.a.com/a.js https://www.a.com/b.js 同一域名，不同协议（http和https） 不允许 不能 http://www.a.com/a.js http://70.32.92.74/b.js 域名和域名对应ip 不允许 能 http://www.cnblogs.com/a.js http://www.a.com/b.js http://script.a.com/b.js http://a.com/b.js 不同域名(host) 不允许 能 1) $.ajax()为我们提供了两种解决方案，不过都是只支持get方式，分别是jQuery的jQuery.ajax“jsonp”格式和jquery.getScript()（即jQuery.ajax “script”格式）方式。2) $.ajax()跨域原理分析由于javascript的安全限制“同源策略”，所以我们无法使用XMLHttpRequest直接请求别的域名下的资源。不过拥有src属性和href属性的script\img\iframe和link\a标签不受同源策略影响。$.ajax()提供的两种解决方案正是应用了动态创建script的方式来实现（即：生成script标签，src引入脚本，然后执行，最后移除script标签）。3) jQuery.ajax()的jsonp和script方式的异同点：a) 相同：都走$.ajax() script格式的流程；不会触发全局事件和局部事件；只支持GET方式（POST请求会自动转化为GET请求）；默认不启用缓存(cache:false)b) 不同：jsonp方式可以通过jsonp和jsonpCallback参数指定一个特定回调函数。4) 示例部署说明： 因为是跨域请求，所以需要在本机部署两个示例程序以模拟不同域之间的访问，并且在示例代码中需要修改“crossUrl”为目的域路径。5) jsonp示例代码：客服端：123456789101112131415// jsonp方式跨域请求(dataType:jsonp)$(&apos;#btn_cross_req1&apos;).bind(&apos;click&apos;, null , function () &#123; $.ajax(crossUrl, &#123; type: &apos;get&apos;, dataType: &apos;jsonp&apos;, jsonp: &apos;jsonpParamName&apos;, jsonpCallback: &apos;crossCallback&apos;, crossDomain: true, &#125;);&#125;);function crossCallback(data) &#123;alert(&apos;jsonp&apos; + data); &#125; 服务端： 123context.Response.ContentType = &quot;text/plain&quot;;string jsonpCallbackName = reqCollection[&quot;jsonpParamName&quot;]; context.Response.Write(String.Format(&quot;&#123;0&#125;(&apos;来自域:&#123;1&#125;的相应信息&apos;)&quot;, jsonpCallbackName, context.Request.Url.Host)); 分析：a) 因jsonp和jsonpCallback参数而改变的url如下。（即默认为：callback=jQuery随机值，更改为：jsonpParamName=crossCallback）URL:http://192.168.1.100:6567/AjaxHandler.ashx?func=CrossRequest&amp;jsonpParamName=crossCallback&amp;_=1368360234428b) 服务器端获取到jsonp回调函数名后，返回一个函数表达式。6) 在XMLHttpRequest Level 2中新增了跨域访问方式、接收二进制等新功能，详细请看：XMLHttpRequest2 新技巧]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ajax源码解析-jQuery ajax相关函数]]></title>
      <url>http://yoursite.com/2016/11/03/ajax_3/</url>
      <content type="text"><![CDATA[解释了ajax源码中一些函数的使用 1) jQuery.ajaxSetup({ })jQuery.ajax()函数中的所有的参数选项都可以通过jQuery.ajaxSetup()函数来全局设置默认值。 2) $.ajax()函数的封装a) $(“”).load(url [, params] [, callback])请求远程的HTML文件代码(dataType: “html”)，默认使用 GET 方式，如果传递了params参数则使用Post方式。在请求“成功”完成时将responseText属性值插入至DOM中。但不管请求是否成功完成“在最后”都会执行callback回调函数(即：complete:callback)。b) jQuery.get(url [, data] [, callback] [, type] )通过HTTP GET请求载入数据，并在请求成功时执行回调函数（即：success: callback）。c) jQuery.getJSON(url [, data] [, callback] )通过 HTTP GET 请求载入 JSON 数据。相当于: jQuery.get(url, [data],[callback], “json”)可以通过使用JSONP 形式的回调函数来加载其他网域的JSON数据。d) jQuery.getScript(url [, callback] )通过 HTTP GET 请求载入并执行一个 JavaScript 文件。相当于: jQuery.get(url, null, [callback], “script”)可以跨域调用 JavaScript 文件。e) jQuery.post(url [, data] [, callback] [, type] )通过 HTTP POST 请求载入信息，并在请求成功时执行回调函数（即：success: callback）。 3) 对象序列化a) jQuery.param(object,traditional)创建数组或对象的序列化表示，该序列化可在ajax请求时在URL查询字符串中使用。序列化过程中会使用encodeURIComponent()函数把字符串作为URI组件进行编码。encodeURIComponent() 方法不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码： - _ . ! ~ * ‘ ( ) 。其他字符（比如：;/?:@&amp;=+$,# 这些用于分隔 URI 组件的标点符号），都是由一个或多个十六进制的转义序列替换的。// 在param中会进行如下处理12345function( key, value ) &#123; // 如果value是函数，则取其函数返回值 value = jQuery.isFunction( value ) ? value() : value; s[ s.length ] = encodeURIComponent( key ) + &quot;=&quot; + encodeURIComponent( value );&#125;; 对于 jQuery 1.4，$.param() 方法将会通过深度递归的方式序列化对象，以便符合现代化脚本语言的需求，比如 PHP、Ruby on Rails 等。你可以传递traditional = true 或在ajax功能中传递包含traditional的options参数。传送门：$.param()深度递归详解和$.param() 示例b) $(“”).serializeArray()可以将一个或多个表单元素（比如 input、 textarea等），或者 form 元素本身的jQuery对象序列化为JSON对象。（非 JSON 字符串。需要使用插件或者第三方库进行字符串化操作）特别说明，元素不能被禁用（禁用的元素不会被包括在内），并且元素应当有含有 name 属性。提交按钮的值也不会被序列化。文件选择元素的数据也不会被序列化。传送门：$(“”).serializeArray() 示例c) $(“”).serialize()可以将一个或多个表单元素（比如 input、 textarea等），或者 form 元素本身的jQuery对象序列化为经过URL编码转换后的字符串，可直接用在URL查询字符串中。jQuery内部定义：123serialize: function() &#123; return jQuery.param( this.serializeArray() );&#125; 传送门：$(“”).serialize()示例]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ajax源码解析-jQuery Ajax事件]]></title>
      <url>http://yoursite.com/2016/11/03/ajax_2/</url>
      <content type="text"><![CDATA[jQuery框架中，伴随Ajax请求会触发若干事件，我们可以订阅这些事件并在其中处理我们的逻辑。在jQuery中有两种Ajax事件：局部事件和全局事件。 局部事件（回调函数）在$.ajax()方法的options参数中声明，可以用来设置请求数据和获取、处理响应数据。 局部事件 具体解析 beforeSend 该函数可在发送请求前修改XMLHttpRequest对象，如添加自定义 HTTP 头。签名：function (jqXHR,s) { }函数说明：传入jqXHR、s对象 dataFilter 在请求成功之后调用。若状态码为304(未修改)则不触发此回调。签名：function (data, dataType) { return newData; } 函数说明：传入返回的数据、”dataType”参数的值。并且必须返回新的数据传递给success回调函数 success 请求成功时触发。签名：function (data,statusText,jqXHR) { } 函数说明：传入返回的数据、描述状态的字符串”success”、jqXHR对象 error 请求失败时调用此函数。签名：function (jqXHR, textStatus, errorThrown) { } 函数说明：传入jqXHR对象、描述状态的字符串”error”、错误信息 complete 请求完成后回调函数 (请求成功或失败之后均调用)签名：function (jqXHR, textStatus) { } 函数说明：传入jqXHR对象、描述状态的字符串（可能值：”No Transport”、”timeout”、”notmodified”—304 “、”parsererror”、”success”、”error”） 定义方式例如：12345678910$.ajax(&#123; // ... beforeSend: function()&#123; // Handle the beforeSend event &#125;, complete: function()&#123; // Handle the complete event &#125; // ...&#125;); 全局事件 每次Ajax请求都会触发，它会向DOM中的所有元素广播，你只需为DOM中任意元素bind好全局事件即会触发（若绑定多次，则会依次触发为事件注册的回调函数）。 全局事件 具体解析 ajaxStart 开始新的Ajax请求，并且此时jQuery对象上没有其他ajax请求正在进行。签名：function(e) 函数说明：传入事件对象 ajaxSend 当一个Ajax请求开始时触发签名：function(e,jqXHR,s) 函数说明：传入事件对象、jqXHR、s对象 ajaxSuccess 全局的请求成功 签名：function(e,jqXHR,s,data) 函数说明：传入事件对象、jqXHR、s对象、请求成功返回的相应数据 ajaxError 全局的发生错误时触发 签名：function(e,jqXHR,s,errorData) 函数说明：传入事件对象、jqXHR、s对象、请求失败返回的错误信息 ajaxComplete 全局的请求完成时触发 签名：function(e,jqXHR,s) 函数说明：传入事件对象、jqXHR、s对象 ajaxStop 当jQuery对象上正在进行Ajax请求都结束时触发。签名：function(e) 函数说明：传入事件对象 全局事件在jQuery中的声明方式：12345jQuery.each( &quot;ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend&quot;.split( &quot; &quot; ), function( i, o )&#123; jQuery.fn[ o ] = function( f )&#123; return this.on( o, f ); &#125;;&#125;); 所以我们可以使用下面两种方式定义全局事件：1234// 可以用bind来绑定，用unbind来取消绑定。$(&quot;#loading&quot;).bind(&quot;ajaxSend&quot;, function()&#123; … &#125;);或者：$(&quot;#loading&quot;).ajaxStart(function()&#123; … &#125;); ajax方法完整的事件流成功的ajax事件流失败的ajax事件流 示例：$.ajax()触发的事件(局部事件和全局事件)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 全局事件$(&quot;#div_event&quot;).ajaxStart(function (e) &#123; doAddEvent4textarea(&apos;txt_event&apos;, &apos;触发ajaxStart回调函数&apos;);&#125;);$(&quot;#div_event&quot;).ajaxSend(function (e) &#123; doAddEvent4textarea(&apos;txt_event&apos;, &apos;触发ajaxSend回调函数&apos;);&#125;);$(&quot;#div_event&quot;).ajaxSuccess(function (e, jqXHR, s, data) &#123; doAddEvent4textarea(&apos;txt_event&apos;, &apos;触发ajaxSuccess回调函数&apos;);&#125;);$(&quot;#div_event&quot;).ajaxError(function (e, jqXHR, s, errorData) &#123; doAddEvent4textarea(&apos;txt_event&apos;, &apos;触发ajaxError回调函数&apos;);&#125;);$(&quot;#div_event&quot;).ajaxComplete(function (e, jqXHR, s) &#123; doAddEvent4textarea(&apos;txt_event&apos;, &apos;触发ajaxComplete回调函数&apos;);&#125;);$(&quot;#div_event&quot;).ajaxStop(function (e) &#123; doAddEvent4textarea(&apos;txt_event&apos;, &apos;触发ajaxStop回调函数&apos;);&#125;);// 局部事件function bindLocalEvent(e) &#123; var textareaid = e.data.textareaid; var global = e.data.global; $.ajax(&apos;AjaxHandler.ashx?func=btn_nowTime_long&apos;, &#123; type: &apos;get&apos;, dataType: &apos;text&apos;, global: global, cache: false, beforeSend: function (jqXHR, s) &#123; doAddEvent4textarea(textareaid, &apos;触发beforeSend回调函数&apos;); &#125;, dataFilter: function (data, dataType) &#123; doAddEvent4textarea(textareaid, &apos;触发dataFilter回调函数&apos;); &#125;, success: function (data, statusText, jqXHR) &#123; doAddEvent4textarea(textareaid, &apos;触发success回调函数&apos;); &#125;, error: function (jqXHR, textStatus, errorThrown) &#123; doAddEvent4textarea(textareaid, &apos;触发error回调函数&apos;); &#125;, complete: function (jqXHR, textStatus) &#123; doAddEvent4textarea(textareaid, &apos;触发complete回调函数&apos;); &#125; &#125;);&#125;function doAddEvent4textarea(textareaid, txt) &#123; var textarea = $(&quot;#&quot; + textareaid); textarea.val(textarea.val() + &apos;\r\n&apos; + txt);&#125; $.ajax()方法的全局事件典型用例 你的页面存在多个甚至为数不少的ajax请求，但是这些ajax请求都有相同的消息机制。ajax请求开始前显示一个提示框，提示“正在读取数据”；ajax请求成功时提示框显示“数据获取成功”；ajax请求结束后隐藏提示框。 a) 不使用全局事件的做法是：给$.ajax()加上beforeSend、success、complete回调函数，在回调函数中加上处理提示框。b) 使用全局事件的做法是：123456$(document).ajaxStart(onStart) .ajaxComplete(onComplete) .ajaxSuccess(onSuccess);function onStart(event) &#123; //..... &#125;function onComplete(event, xhr, settings) &#123; //..... &#125;function onSuccess(event, xhr, settings) &#123; //..... &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[技术文档]]></title>
      <url>http://yoursite.com/2016/11/03/tecLink/</url>
      <content type="text"><![CDATA[http相关 jQuery相关等技术文档 1) jQuery相关jQueryAPI文档jQuery百度百科(Eg：模块，历史版本)Ajax 技术资源中心（IBM）这是有关 Ajax 编程模型信息的一站式中心，包括很多文档、教程、论坛、blog、wiki 和新闻。任何 Ajax 的新信息都能在这里找到。jQuery.ajax()中的预过滤器和分发机制函数inspectPrefiltersOrTransports详解jQuery的deferred对象详解$.param()深度递归详解 2) XMLHttpRequest Level 2 的新功能相关XMLHttpRequest 增强功能XMLHttpRequest Level 2 使用指南XMLHttpRequest2 新技巧 3) 跨域请求相关JavaScript跨域总结与解决办法总结了5种js跨域方式：利用iframe标签和document.domain属性、动态创建scrip、利用iframe标签和location.hash属性、window.name实现的跨域数据传输、使用HTML5 postMessage、利用flash跨域。域名和IP地址及域名解析xhr注入_百度百科说说JSON和JSONP 4) HTTP相关HTTP深入浅出 http请求1) 介绍了一次HTTP通信的7个步骤：建立TCP连接、Web浏览器向Web服务器发送请求命令、Web浏览器发送请求头信息、Web服务器应答、Web服务器发送应答头信息、Web服务器向浏览器发送数据、Web服务器关闭TCP连接2) 介绍HTTP请求格式HTTP GET和POST的区别HTTP 头部详解HTTP Content-type对照表格式：Content-Type: [type]/[subtype]; parameterHTTP状态码一览表（HTTP Status Code） 5）Jquery其他部分不定义JQuery插件，不要说会JQuery]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ajax源码解析-源码流程]]></title>
      <url>http://yoursite.com/2016/11/02/ajax_1/</url>
      <content type="text"><![CDATA[ajax源码 了解执行的整个过程 参照注释看相关文章 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200ajax: function (url, options) &#123; if (typeof url === &quot;object&quot;) &#123; options = url; url = undefined; &#125; options = options || &#123;&#125;; // 由ajaxSetting和入口传入的option合成的对象s， //jQuery.ajaxSetup等函数的使用 参见文章ajax源码解析-jQuery ajax相关函数 var s = jQuery.ajaxSetup(&#123;&#125;, options)。。。 &lt;!--其他变量也在此处声明 省略--&gt; //对象s内的各个参数详解，参见文章ajax源码解析-s对象和jqXHR对象 jqXHR = &#123; readyState: 0, setRequestHeader: function (name, value) &#123; &#125;, getAllResponseHeaders: function () &#123; &#125;, getResponseHeader: function (key) &#123; &#125;, overrideMimeType: function (type) &#123; &#125;, abort: function (statusText) &#123; &#125; &#125;; function done(status, nativeStatusText, responses, headers) &#123; &#125; // Attach deferreds // 开发网站的过程中，我们经常遇到某些耗时很长的javascript操作。其中，既有异步的操作（比如ajax读取服务器数据），也有同步的操作（比如遍历一个大型数组），它们都不是立即能得到结果的。 // 通常的做法是，为它们指定回调函数（callback）。即事先规定，一旦它们运行结束，应该调用哪些函数。 // deferred对象就是jQuery的回调函数解决方案 &apos;延迟执行&apos; deferred.promise(jqXHR); jqXHR.success = jqXHR.done; jqXHR.error = jqXHR.fail; jqXHR.complete = completeDeferred.add; // Status-dependent callbacks jqXHR.statusCode = function (map) &#123; &#125;; // 处理url 去掉hash地址和添加协议 // 例如 var c=&quot;//brandshow.58.com/show/loadBrandAds#top&quot; // c.replace(rhash, &quot;&quot;).replace(rprotocol, ajaxLocParts[1] + &quot;//&quot;); // 结果&quot;http://brandshow.58.com/show/loadBrandAds&quot;--&gt; s.url = ( ( url || s.url ) + &quot;&quot; ).replace(rhash, &quot;&quot;).replace(rprotocol, ajaxLocParts[1] + &quot;//&quot;); // 处理dataType数据类型，去除空格，转换成数组 s.dataTypes = jQuery.trim(s.dataType || &quot;*&quot;).toLowerCase().split(rspacesAjax) // 来判断是否跨域 协议 域名 端口号 必须一致 if (s.crossDomain == null) &#123; parts = rurl.exec(s.url.toLowerCase()); //parts返回值（以数组形式包含协议 域名 端口号；然后分别和当前地址的协议 域名 端口号比较，有一处不等则判断为跨域 ） // 例如：[&quot;http://api.house.58.com&quot;, &quot;http:&quot;, &quot;api.house.58.com&quot;, undefined] s.crossDomain = !!( parts &amp;&amp; ( parts[1] != ajaxLocParts[1] || parts[2] != ajaxLocParts[2] || ( parts[3] || ( parts[1] === &quot;http:&quot; ? 80 : 443 ) ) != ( ajaxLocParts[3] || ( ajaxLocParts[1] === &quot;http:&quot; ? 80 : 443 ) ) ) ); &#125; //处理数据data序列化 例如&#123;userId:42437217099799,cateId:8&#125;转化为userId=42437217099799&amp;cateId=8&quot; if (s.data &amp;&amp; s.processData &amp;&amp; typeof s.data !== &quot;string&quot;) &#123; s.data = jQuery.param(s.data, s.traditional); &#125; // Apply prefilters // prefilters前置过滤器 // jQuery1.5以后，AJAX模块提供了三个新的方法用于管理、扩展AJAX请求，分别是： // 1.前置过滤器 jQuery. ajaxPrefilter // 2.请求分发器 jQuery. ajaxTransport， // 3.类型转换器 ajaxConvert //参见文章ajax源码解析-jQuery. ajaxPrefilter和jQuery. ajaxTransport， // prefilters对象 Object &#123;json: Array[1], jsonp: Array[1], script: Array[1]&#125; &lt;!--前置过滤器主要预处理参数 举例 dataType：json或者jsonp 会一次经过jQuery. ajaxPrefilter(&quot;json jsonp&quot;)和jQuery. ajaxPrefilter(&quot;script&quot;) 结果：url会拼接上s.jsonp+jsonpcallback(如?callback=jQuery4781297478394_481274389) s.cache=false; 如果是跨域 s.type = &quot;GET&quot;; s.global = false; --&gt; inspectPrefiltersOrTransports(prefilters, s, options, jqXHR); // If request was aborted inside a prefiler, stop there if (state === 2) &#123; return false; &#125; // We can fire global events as of now if asked to fireGlobals = s.global; // Uppercase the type s.type = s.type.toUpperCase(); // Determine if request has content s.hasContent = !rnoContent.test(s.type); // Watch for a new set of requests if (fireGlobals &amp;&amp; jQuery.active++ === 0) &#123; jQuery.event.trigger(&quot;ajaxStart&quot;); &#125; // More options handling for requests with no content &lt;!--s.hasContent 非GET或HEAD请求为true，用于处理data和contentType参数。--&gt; if (!s.hasContent) &#123; // If data is available, append data to url if (s.data) &#123; &lt;!--把传递的数据data以参数形式拼接到请求的url--&gt; s.url += ( rquery.test(s.url) ? &quot;&amp;&quot; : &quot;?&quot; ) + s.data; // #9682: remove data so that it&apos;s not used in an eventual retry delete s.data; &#125; // Get ifModifiedKey before adding the anti-cache parameter ifModifiedKey = s.url; // Add anti-cache in url if needed if (s.cache === false) &#123; 默认cache为false 即无缓存 处理方法在请求地址后面加时间戳 var ts = jQuery.now(), // try replacing _= if it is there ret = s.url.replace(rts, &quot;$1_=&quot; + ts); // if nothing was replaced, add timestamp to the end s.url = ret + ( ( ret === s.url ) ? ( rquery.test(s.url) ? &quot;&amp;&quot; : &quot;?&quot; ) + &quot;_=&quot; + ts : &quot;&quot; ); &#125; &#125; // Set the correct header, if data is being sent if (s.data &amp;&amp; s.hasContent &amp;&amp; s.contentType !== false || options.contentType) &#123; jqXHR.setRequestHeader(&quot;Content-Type&quot;, s.contentType); &#125; // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode. //If-Modified-Since和If-None-Match 的使用 参见文章ajax源码解析-$.ajax()中常见应用示例 if (s.ifModified) &#123; &#125; // Set the Accepts header for the server, depending on the dataType jqXHR.setRequestHeader( &quot;Accept&quot;, s.dataTypes[0] &amp;&amp; s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + ( s.dataTypes[0] !== &quot;*&quot; ? &quot;, &quot; + allTypes + &quot;; q=0.01&quot; : &quot;&quot; ) : s.accepts[&quot;*&quot;] ); // Check for headers option for (i in s.headers) &#123; jqXHR.setRequestHeader(i, s.headers[i]); &#125; // Allow custom headers/mimetypes and early abort if (s.beforeSend &amp;&amp; ( s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2 )) &#123; // Abort if not done already jqXHR.abort(); return false; &#125; // Install callbacks on deferreds for (i in &#123;success: 1, error: 1, complete: 1&#125;) &#123; jqXHR[i](s[i]); &#125; // Get transport &lt;!--请求分发器 一种处理跨越 一种处理xmlHttpRequest请求--&gt; 例如：dataType:json 经过ajax.Prefilters处理 返回dataType[0]==&quot;script&quot; 在经过ajax.Transports处理 如果s.crossmain==true 那么transport会以对象的形式返回两个方法&#123;send:&#123;&#125;,abort:&#123;&#125;&#125;来处理跨域问题 transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR); // 全局事件 ajaxStart ajaxSend等参见文章ajax源码解析-全局事件及局部事件 // If no transport, we auto-abort if (!transport) &#123; done(-1, &quot;No Transport&quot;); &#125; else &#123; jqXHR.readyState = 1; // Send global event if (fireGlobals) &#123; globalEventContext.trigger(&quot;ajaxSend&quot;, [jqXHR, s]); &#125; // Timeout if (s.async &amp;&amp; s.timeout &gt; 0) &#123; timeoutTimer = setTimeout(function () &#123; jqXHR.abort(&quot;timeout&quot;); &#125;, s.timeout); &#125; try &#123; state = 1; &lt;!--经过请求分发器的处理 返回的对象格式一致(不论是跨域请求还是非跨域请求) 即&#123;send:&#123;&#125;,abort:&#123;&#125;&#125;--&gt; transport.send(requestHeaders, done); &#125; catch (e) &#123; // Propagate exception as error if not done if (state &lt; 2) &#123; done(-1, e); // Simply rethrow otherwise &#125; else &#123; throw e; &#125; &#125; &#125; &lt;!--$.ajax(&#123;&#125;)返回的是jqXHR对象，对象内各种属性及方法参见文章ajax源码解析-s对象和jqXHR对象 --&gt; return jqXHR;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ajax源码解析-s对象和jqXHR对象]]></title>
      <url>http://yoursite.com/2016/10/31/ajax/</url>
      <content type="text"><![CDATA[jQuery.ajax( [url,] options ) 通过 HTTP 请求加载远程数据。返回值：$.ajax() 返回jqXHR对象（jqXHR对象：为XMLHttpRequest对象的超集）。可用于手动终止请求abort()、为ajax函数设置额外的回调函数等。 ajax内部实现的两个重要对象：s对象和jqXHR对象。 s对象 s对象由默认设置jQuery.ajaxSettings对象、options参数集合和jQuery.ajaxSetup({})默认设置合并而成s对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081var s = jQuery.ajaxSetup(&#123;&#125;, options)jQuery.extend(&#123; ajaxSetup: function (target, settings) &#123; if (settings) &#123; // Building a settings object ajaxExtend(target, jQuery.ajaxSettings); &#125; else &#123; // Extending ajaxSettings settings = target; target = jQuery.ajaxSettings; &#125; ajaxExtend(target, settings); return target; &#125;, ajaxSettings: &#123; url: ajaxLocation, isLocal: rlocalProtocol.test(ajaxLocParts[1]), global: true, type: &quot;GET&quot;, contentType: &quot;application/x-www-form-urlencoded&quot;, processData: true, async: true, /* timeout: 0, data: null, dataType: null, username: null, password: null, cache: null, traditional: false, headers: &#123;&#125;, */ accepts: &#123; xml: &quot;application/xml, text/xml&quot;, html: &quot;text/html&quot;, text: &quot;text/plain&quot;, json: &quot;application/json, text/javascript&quot;, &quot;*&quot;: allTypes &#125;, contents: &#123; xml: /xml/, html: /html/, json: /json/ &#125;, responseFields: &#123; xml: &quot;responseXML&quot;, text: &quot;responseText&quot; &#125;, // List of data converters // 1) key format is &quot;source_type destination_type&quot; (a single space in-between) // 2) the catchall symbol &quot;*&quot; can be used for source_type converters: &#123; // Convert anything to text &quot;* text&quot;: window.String, // Text to html (true = no transformation) &quot;text html&quot;: true, // Evaluate text as a json expression &quot;text json&quot;: jQuery.parseJSON, // Parse text as xml &quot;text xml&quot;: jQuery.parseXML &#125;, // For options that shouldn&apos;t be deep extended: // you can add your own custom options here if // and when you create one that shouldn&apos;t be // deep extended (see ajaxExtend) flatOptions: &#123; context: true, url: true &#125; &#125;, &#125;) 参数名 描述 可由ajax的options参数设置 url (默认: 当前页地址) 要请求的目的URL地址。 username password 用于响应HTTP访问认证请求的用户名及密码 type (默认: “GET”) 请求方式 (“POST” 或 “GET”)。注意：其它 HTTP 请求方法，如 PUT 和 DELETE 也可以使用，但仅部分浏览器支持。 dataType 预期服务器返回的数据类型。如果不指定，jQuery将自动根据 HTTP 包 MIME 信息来智能判断，比如 XML MIME 类型就被识别为 XML。随后服务器端返回的数据会根据这个值解析后，传递给回调函数。 必须确保网页服务器报告的 MIME 类型与我们选择的dataType所匹配。比如说，XML的话，服务器端就必须声明 text/xml 或者 application/xml 来获得一致的结果。 可用值: 1.”xml”返回 XML 文档，可用jQuery处理。 2.”html”返回纯文本 HTML 信息；包含的 script 标签会在插入dom时执行。 3.”script”返回纯文本 JavaScript 代码，常常用于跨域请求。不会触发全局事件和局部事件；只支持GET方式（POST请求会自动转化为GET请求）；默认不启用缓存(cache:false) 4.”json”返回 JSON 数据。JSON 数据是一种能很方便通过 JavaScript 解析的结构化数据。 5.”jsonp”JSONP 格式，用于跨域请求。6.”text”返回纯文本字符串 其中，text 和 xml 类型返回的数据不会经过处理。数据仅仅简单的将XMLHttpRequest的responseText或responseHTML属性传递给 success 回调函数。 如果指定了 script 或者jsonp类型，那么当从服务器接收到数据时，实际上是用了script标签而不是XMLHttpRequest对象。 这种情况下，$.ajax() 不再返回一个XMLHttpRequest对象，并且也不会传递事件处理函数，比如beforeSend。 contentType (默认: “application/x-www-form-urlencoded”)标明发送或者接收的实体的MIME类型。当“非GET或HEAD请求”的HTTP请求时，会被设置为HTTP头请求信息。 mimeType 多用途互联网邮件扩展（MIME，Multipurpose Internet Mail Extensions）；用于重写服务器端响应的MIME类型。 data 发送到服务器的数据。可以是一个查询字符串，比如 key1=value1&amp;key2=value2 ，也可以是一个映射，比如 {key1: ‘value1’, key2: ‘value2’} 。如果使用了后者的形式，则数据在发送前会通过jQuery.param()函数转换成查询字符串。这个处理过程也可以通过设置processData选项为false来回避。 processData (默认: true) 默认情况下，发送到服务器的数据（即data参数）将被转换为字符串以配合默认内容类型 “application/x-www-form-urlencoded”。如果要发送 DOM 树信息或其它不希望转换的信息，请设置为 false。 jQuery中的处理方式： async (默认: true) 默认设置下，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为 false。注意，同步请求将锁住浏览器，用户其它操作必须等待请求完成才可以执行。 timeout 设置请求超时时间（毫秒）。通过setTimeout(fn,time)实现。 cache (默认: true)dataType为 script 和jsonp时默认为 false。设置为 false 将不缓存此页面。 当使用GET或HEAD方式发送请求时要添加时间戳参数 (net Date()).getTime() 来保证每次发送的URL不同, 可以避免浏览器缓存.（只有GET和HEAD方式的请求浏览器才会缓存） jQuery中的处理方式： ifModified (默认: false) 仅在服务器数据改变时获取新数据。通过响应头If-Modified-Since、IF-None-Match和请求头Last-Modified、Etag提高GET或HEAD方式请求效率。（只有GET和HEAD方式的请求浏览器才会缓存） global (默认: true) 是否触发全局 AJAX 事件。设置为 false 将不会触发全局AJAX 事件：ajaxStart、ajaxSend、ajaxSuccess、ajaxError、ajaxComplete、ajaxStop。（比如请求频繁时可禁用全局AJAX事件提高效率） context (默认：true) 这个对象用于设置Ajax相关回调函数的上下文，让回调函数内this指向这个对象。如果不设定这个参数，那么回调函数中的this就指向调用本次AJAX请求时传递的options参数载体“s对象”。但对于全局Ajax事件来说，this都是指向全局事件所绑定的元素。 jsonp 指定获得jsonp回调函数名的参数名(默认为:callback)。这个值用来替代URL中”callback=?”里的”callback”部分，比如{jsonp:’onJsonPLoad’}会替换为将”onJsonPLoad=?”传给服务器。 jsonpCallback 为jsonp请求指定一个回调函数名。jsonpCallback参数一般为字符串，也可接收函数(该函数返回字符串)。默认情况下生成随机函数名：”jQuery” + ( jQuery.fn.jquery + Math.random() ).replace( /\D/g, “” ) + jQuery.now() crossDomain (默认：null)false：同域请求；true跨域请求。倘若crossDomain标识为null，则jQuery会自动根据本地url、端口来解析。可以根据需求直接赋值来提高性能。 通常情况下由服务器自动解析即可，但如果你想在同一域中强制跨域请求（像JSONP一样），那么将crossDomain为true，这允许你将服务器端重定向到另一个域。 scriptCharset 只有当请求时dataType为”jsonp”或”script”，并且type是”GET”才会用于修改charset。 因为此时是动态创建script来完成脚本加载，但是如果js中的编码与页面的编码不一致时，js可能加载失败或者显示乱码或者IE下报某符号错误。设置此参数就相当于为script标签设置charset属性。 hearders (默认：{}) 设置HTTP请求头数据”{键:值}”。此设置发生在：jQuery所有影响HTTP头的参数(options)设置之后，beforeSend回调函数之前。 statusCode (默认：{}) 定义一组HTTP状态码与回调函数的映射，当响应的状态码有匹配statusCode则会触发对应回调函数。例如，如果响应状态是404，将触发以下警报： traditional 如果你想要用传统的方式来序列化数据，那么就设置为true。请参考$.param()深度递归详解。 xhrFields 声明附加到XMLHttpRequest对象的自定义“key-value”数组。例如，如果需要的话，你可以用它来设置跨域的withCredentials为true，即： xhrFields: { withCredentials: true } 5个局部事件 beforeSend、dataFilter、success、error、complete。（详见后面事件介绍部分） 由ajax函数内部解析或内部提供 dataTypes 由dataType按空格拆分所得。 isLocal 根据协议确定当前url请求的是否为本地请求。 jQuery中定义默认值为： hasContent 非GET或HEAD请求为true，用于处理data和contentType参数。 contents 一个”{类型字符串:正则表达式}”的对象，倘若dataTypes[0]为“*”时，用contents中的正则表达式去匹配contentType，匹配成功则用“类型字符串”覆盖dataTypes[0]。 jQuery内部定义如下： accepts 浏览器能够处理的媒体类型，其值取决于dataTypes[0]参数。 jQuery内部定义如下： responseFields jqXHR超集设置“数据类型:属性”对应关系，在返回响应数据时，用于确定创建哪个属性变量。 jQuery中定义如下： converters 存储数据类型对应的转换器，根据dataTypes获取对应转换器，用于对响应数据response进行处理。该处理发生在dataFilter回调函数之后。 jqXHR对象jqXHR对象为不同浏览器内置的XMLHttpRequest提供了一致的超集。对于XMLHttpRequest之外的传输机制，比如JSONP请求，jXHR对象也可以进行处理。超集与真子集：如果一个集合S2中的每一个元素都在集合S1中，且集合S1中可能包含S2中没有的元素，则集合S1就是S2的一个超集。 S1是S2的超集，则S2是S1的真子集，反之亦然。 jqXHR对象我们常常使用如下成员，这些成员主要用于ajax的全局事件和局部事件，并且做为$.ajax()函数返回值返回。12345678910jqXHR:&#123; readyState ,setRequestHeader: function( name, value ) ,getAllResponseHeaders: function() ,getResponseHeader: function( key ) ,overrideMimeType: function( type ) ,abort: function( statusText ) ,responseText ,responseXML&#125; 另外，jqXHR的全部成员如下： 1.在图中我们看到一些陌生的函数，比如：done()、fail()、promise()、isResolve()、isRejected()、then()、always()、progress()等，都是jQuery的deferred对象API。 开发网站的过程中，我们经常遇到某些耗时很长的javascript操作。其中，既有异步的操作（比如ajax读取服务器数据），也有同步的操作（比如遍历一个大型数组），它们都不是立即能得到结果的。 2.通常的做法是，为它们指定回调函数（callback）。即事先规定，一旦它们运行结束，应该调用哪些函数。但是，在回调函数方面，jQuery的功能非常弱。为了改变这一点，jQuery开发团队就设计了deferred对象。 简单说，deferred对象就是jQuery的回调函数解决方案。在英语中，defer的意思是”延迟”，所以deferred对象的含义就是”延迟”到未来某个点再执行。 它解决了如何处理耗时操作的问题，对那些操作提供了更好的控制，以及统一的编程接口。 更专业的资源：jQuery的deferred对象详解]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo搭建个人博客]]></title>
      <url>http://yoursite.com/2016/10/28/hexo/</url>
      <content type="text"><![CDATA[搭建博客参考文章Next主题]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JSON 格式]]></title>
      <url>http://yoursite.com/2016/10/28/JSON/</url>
      <content type="text"><![CDATA[JSON格式（JavaScript Object Notation的缩写）是一种用于数据交换的文本格式 JSON格式JSON对值的类型和格式有严格的规定。 1.复合类型的值只能是数组或对象，不能是函数、正则表达式对象、日期对象。2.简单类型的值只有四种：字符串、数值（必须以十进制表示）、布尔值和null（不能使用NaN, Infinity, -Infinity和undefined）。3.字符串必须使用双引号表示，不能使用单引号。4.对象的 键名必须放在双引号里面。5.数组或对象最后一个成员的后面，不能加逗号。 以下是合格的JSON值。1234[&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]&#123; &quot;one&quot;: 1, &quot;two&quot;: 2, &quot;three&quot;: 3 &#125;&#123;&quot;names&quot;: [&quot;张三&quot;, &quot;李四&quot;] &#125;[ &#123; &quot;name&quot;: &quot;张三&quot;&#125;, &#123;&quot;name&quot;: &quot;李四&quot;&#125; ] 以下是不合格的JSON值。123456789&#123; name: &quot;张三&quot;, &apos;age&apos;: 32 &#125; // 属性名必须使用双引号[32, 64, 128, 0xFFF] // 不能使用十六进制值&#123; &quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: undefined &#125; // 不能使用undefined&#123; &quot;name&quot;: &quot;张三&quot;, &quot;birthday&quot;: new Date(&apos;Fri, 26 Aug 2011 07:13:10 GMT&apos;), &quot;getName&quot;: function() &#123; return this.name; &#125;&#125; // 不能使用函数和日期对象 需要==注意==的是，空数组和空对象都是合格的JSON值，null本身也是一个合格的JSON值。ES5新增了JSON对象，用来处理JSON格式数据。它有两个方法：JSON.stringify()和JSON.parse()。 JSON.stringify() JSON.stringify方法用于将一个值转为字符串。该字符串应该 符合JSON格式，并且可以被JSON.parse方法还原 第一个参数1234567JSON.stringify(&apos;abc&apos;) // &quot;&quot;abc&quot;&quot; JSON.stringify(1) // &quot;1&quot; JSON.stringify(false) // &quot;false&quot; JSON.stringify([]) // &quot;[]&quot; JSON.stringify(&#123;&#125;) // &quot;&#123;&#125;&quot; JSON.stringify([1, &quot;false&quot;, false])// &apos;[1,&quot;false&quot;,false]&apos; JSON.stringify(&#123; name: &quot;张三&quot; &#125;)// &apos;&#123;&quot;name&quot;:&quot;张三&quot;&#125;&apos; 注意：对于原始类型的字符串，转换结果会带双引号，即字符串abc会被转成”abc”，这是因为将来还原的时候，双引号可以让JavaScript引擎知道，abc是一个字符串，而不是一个变量名。 12345JSON.stringify(&#123; f: function()&#123;&#125;, a: [ function()&#123;&#125;, undefined ]&#125;);// &quot;&#123;&quot;a&quot;: [null,null]&#125;&quot; 如果原始对象中，有一个 成员的值是undefined、函数或XML对象，这个成员会被省略。如果 数组的成员是undefined、函数或XML对象，则这些值被转成null。 正则对象会被转成空对象。要是正则对象装换成字符串要借助toJSON方法，后面介绍了12JSON.stringify(/foo/) // &quot;&#123;&#125;&quot;JSON.stringify方法会忽略对象的不可遍历属性。 123456789101112var obj = &#123;&#125;;Object.defineProperties(obj, &#123; &apos;foo&apos;: &#123; value: 1, enumerable: true &#125;, &apos;bar&apos;: &#123; value: 2, enumerable: false &#125;&#125;);JSON.stringify(obj); // &#123;&quot;foo&quot;:1&#125; 上面代码中，bar是obj对象的不可遍历属性，JSON.stringify方法会忽略这个属性。 第二个参数JSON.stringify方法还可以接受一个数组，作为第二个参数，指定需要转成字符串的属性。12345678var obj = &#123; &apos;prop1&apos;: &apos;value1&apos;, &apos;prop2&apos;: &apos;value2&apos;, &apos;prop3&apos;: &apos;value3&apos;&#125;;var selectedProperties = [&apos;prop1&apos;, &apos;prop2&apos;];JSON.stringify(obj, selectedProperties)// &quot;&#123;&quot;prop1&quot;:&quot;value1&quot;,&quot;prop2&quot;:&quot;value2&quot;&#125;&quot; 上面代码中，JSON.stringify方法的第二个参数指定，只转prop1和prop2两个属性。 这个类似“白名单”的数组，只对对象的属性有效，对数组无效。1234JSON.stringify([&apos;a&apos;, &apos;b&apos;], [&apos;0&apos;])// &quot;[&quot;a&quot;,&quot;b&quot;]&quot;JSON.stringify(&#123;0: &apos;a&apos;, 1: &apos;b&apos;&#125;, [&apos;0&apos;])// &quot;&#123;&quot;0&quot;:&quot;a&quot;&#125;&quot; 上面代码中，第二个参数指定JSON格式只转0号属性，实际上对数组是无效的，只对对象有效。 第二个参数还可以是一个函数，用来更改JSON.stringify的默认行为。12345678function f(key, value) &#123; if (typeof value === &quot;number&quot;) &#123; value = 2 * value; &#125; return value;&#125;JSON.stringify(&#123; a: 1, b: 2 &#125;, f)// &apos;&#123;&quot;a&quot;: 2,&quot;b&quot;: 4&#125;&apos; 上面代码中的f函数，接受两个参数，分别是被转换的对象的键名和键值。如果键值是数值，就将它乘以2，否则就原样返回。 注意，这个处理函数是递归处理所有的键。1234567891011var o = &#123;a: &#123;b: 1&#125;&#125;;function f(key, value) &#123; console.log(&quot;[&quot;+ key +&quot;]:&quot; + value); return value;&#125;JSON.stringify(o, f)// []:[object Object]// [a]:[object Object]// [b]:1// &apos;&#123;&quot;a&quot;:&#123;&quot;b&quot;:1&#125;&#125;&apos; 上面代码中，对象o一共会被f函数处理三次。第一次键名为空，键值是整个对象o；第二次键名为a，键值是{b: 1}；第三次键名为b，键值为1。递归处理中，每一次处理的对象，都是前一次返回的值。 123456789var o = &#123;a: 1&#125;;function f(key, value) &#123; if (typeof value === &apos;object&apos;) &#123; return &#123;b: 2&#125;; &#125; return value * 2;&#125;JSON.stringify(o,f)// &quot;&#123;&quot;b&quot;: 4&#125;&quot; 上面代码中，f函数修改了对象o，接着JSON.stringify方法就递归处理修改后的对象o。 如果处理函数返回undefined或没有返回值，则该属性会被忽略。123456789function f(key, value) &#123; if (typeof(value) === &quot;string&quot;) &#123; return undefined; &#125; return value;&#125;JSON.stringify(&#123; a: &quot;abc&quot;, b: 123 &#125;, f)// &apos;&#123;&quot;b&quot;: 123&#125;&apos; 上面代码中，a属性经过处理后，返回undefined，于是该属性被忽略了。 第三个参数JSON.stringify还可以接受第三个参数，用于增加返回的JSON字符串的可读性。如果是数字，表示每个属性前面添加的空格（最多不超过10个）；如果是字符串（不超过10个字符），则该字符串会添加在每行前面。123456789101112131415JSON.stringify(&#123; p1: 1, p2: 2 &#125;, null, 2);/*&quot;&#123; &quot;p1&quot;: 1, &quot;p2&quot;: 2&#125;&quot;*/JSON.stringify(&#123; p1:1, p2:2 &#125;, null, &apos;|-&apos;);/*&quot;&#123;|-&quot;p1&quot;: 1,|-&quot;p2&quot;: 2&#125;&quot;*/ toJSON 方法如果JSON.stringify方法处理的对象，包含一个toJSON方法，则它会使用这个方法得到一个值，然后再将这个值转成字符串，而忽略其他成员。toJSON()可以作为函数过滤器的补充，因此 理解序列化的内部顺序十分重要。假设把一个对象传入JSON.stringify()，序列化该对象的顺序如下。 (1) 如果存在toJSON()方法而且能通过它取得有效的值，则调用该方法。否则，返回对象本身。(2) 如果提供了第二个参数，应用这个函数过滤器。传入函数过滤器的值是第(1)步返回的值。(3) 对第(2)步返回的每个值进行相应的序列化。(4) 如果提供了第三个参数，执行相应的格式化。无论是考虑定义toJSON()方法，还是考虑使用函数过滤器，亦或需要同时使用两者，理解这个顺序都是至关重要的。 123456789101112131415JSON.stringify(&#123; toJSON: function () &#123; return &quot;Cool&quot; &#125;&#125;)// &quot;&quot;Cool&quot;&quot;var o = &#123; foo: &apos;foo&apos;, toJSON: function() &#123; return &apos;bar&apos;; &#125;&#125;;var json = JSON.stringify(&#123;x: o&#125;);// &apos;&#123;&quot;x&quot;:&quot;bar&quot;&#125;&apos; Date对象就部署了一个自己的toJSON方法。。原生Date 对象有一个toJSON()方法12JSON.stringify(new Date(&quot;2011-07-29&quot;))// &quot;2011-07-29T00:00:00.000Z&quot; toJSON方法的一个应用是，可以将正则对象自动转为字符串。123RegExp.prototype.toJSON = RegExp.prototype.toString;JSON.stringify(/foo/)// &quot;/foo/&quot; 理解序列化的执行顺序 就可以解释该结果产生的原因 上面代码，在正则对象的原型上面部署了toJSON方法，将其指向toString方法，因此遇到转换成JSON时，正则对象就先调用toJSON方法转为字符串，然后再被JSON.stingify方法处理。 JSON.parse() JSON.parse方法用于将JSON字符串转化成对象。 1234567JSON.parse(&apos;&#123;&#125;&apos;) // &#123;&#125;JSON.parse(&apos;true&apos;) // trueJSON.parse(&apos;&quot;foo&quot;&apos;) // &quot;foo&quot;JSON.parse(&apos;[1, 5, &quot;false&quot;]&apos;) // [1, 5, &quot;false&quot;]JSON.parse(&apos;null&apos;) // nullvar o = JSON.parse(&apos;&#123;&quot;name&quot;: &quot;张三&quot;&#125;&apos;);o.name // 张三 如果传入的字符串不是有效的JSON格式，JSON.parse方法将报错。12JSON.parse(&quot;&apos;String&apos;&quot;) // illegal single quotes// SyntaxError: Unexpected token ILLEGAL 上面代码中，双引号字符串中是一个单引号字符串，因为单引号字符串不符合JSON格式，所以报错。 为了处理解析错误，可以将JSON.parse方法放在try…catch代码块中。JSON.parse方法可以接受一个处理函数，用法与JSON.stringify方法类似。123456789101112function f(key, value) &#123; if (key === &apos;&apos;)&#123; return value; &#125; if (key === &apos;a&apos;) &#123; return value + 10; &#125;&#125;var o = JSON.parse(&apos;&#123;&quot;a&quot;:1,&quot;b&quot;:2&#125;&apos;, f);o.a // 11o.b // undefined 注意 与下面代码比较的区别12345678910111213function f(key, value) &#123; if (key === &apos;&apos;)&#123; return value; &#125; if (key === &apos;a&apos;) &#123; return value + 10; &#125;else&#123; return value&#125;var o = JSON.parse(&apos;&#123;&quot;a&quot;:1,&quot;b&quot;:2&#125;&apos;, f);o.a // 11o.b // 2 兼容性问题 – | - - | - - | - - | - - | - -Feature |Chrome| Firefox (Gecko)| Internet Explorer |Opera |SafariBasic |support (Yes)| 3.5 (1.9.1)| 8.0| 10.5 |4.0 常见问题 ie6 7下不支持JSON解决方法一：1234567var jsons = req.responseText; var s; if (typeof(JSON) == &apos;undefined&apos;)&#123; s = eval(&quot;(&quot;+jsons+&quot;)&quot;); &#125;else&#123; s = JSON.parse(jsons); &#125; 解决方法二：调用的页面里引用json2.js即可解决问题（由于安全性问题 推荐方法二）。1&lt;script type=&quot;text/javascript&quot; src=&quot;js/json2.js&quot;&gt;&lt;/script&gt; json2.js地址 http://j2.58cdn.com.cn/js/v8/modules/common/json2.js或者到官网下载http://www.json.org/js.htmlgithub：https://github.com/douglascrockford/JSON-js]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[js小记]]></title>
      <url>http://yoursite.com/2016/10/27/jsSummary/</url>
      <content type="text"><![CDATA[平时遇到的js一些方法，或者是面试题，又或者总结之类的。。 javascript有哪些方法定义对象对象字面量： var obj = {}; 构造函数： var obj = new Object(); Object.create(): var obj = Object.create(Object.prototype); 判断对象是否含有某个属性(in 和 hasOwnProperty区别)12345678function car()&#123;this.name=&apos;sbx&apos;;this.age=&quot;1234&quot;&#125; var car1=new car() car.prototype.sex=&quot;nv&quot; car1.constructor//car()&#123;this.name=&apos;sbx&apos;;this.age=&quot;1234&quot;&#125; car1.hasOwnProperty(&quot;name&quot;)//true car1.hasOwnProperty(&quot;sex&quot;)//false &quot;name&quot; in car1//true &quot;sex&quot; in car1//true 判断某个属性是否存在与某个对象中,可以通过in运算符,hasOwnProperty()和propertyIsEnumerable()方法来完成.in运算符,如果对象的自有属性或继承属性中包含这个属性,则返回true.对象的hasOwnProperty()方法用来检测给定的名字是否是对象的自有属性.propertyIsEnumerable()是hasOwnProperty()的增强版,只有检测到时自有属性且这个属性的可枚举性为true时才能返回true.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[深入理解javascript的闭包特性]]></title>
      <url>http://yoursite.com/2016/10/26/closure/</url>
      <content type="text"><![CDATA[理解JavaScript的闭包是迈向高级JS程序员的必经之路，理解了其解释和运行机制才能写出更为安全和优雅的代码 变量的作用域要理解闭包，首先必须理解Javascript特殊的变量作用域。变量的作用域无非就是两种：全局变量和局部变量。1.Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。 12345var n=999; function f1()&#123; alert(n); &#125; f1(); // 999 2.另一方面，在函数外部自然无法读取函数内的局部变量。 1234 function f1()&#123; var n=999; &#125; alert(n); // error 这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！ 12345 function f1()&#123; n=999; &#125; f1(); alert(n); // 999 如何从外部读取函数内部变量的？正常情况下f1内局部变量访问不到，只能内部定义一个函数 123456 function f1()&#123; var n=999; function f2()&#123; alert(n); // 999 &#125; &#125; f1内部变量对f2可见，而f2内部变量对f1不可见 这就是Javascript语言特有的“链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。 既然这样，将f2作为返回值，就可以访问到f1内部的变量，达到了外部访问f1内部变量的目的 123456789 function f1()&#123; var n=999; function f2()&#123; alert(n); &#125; return f2； &#125; var f=f1();f();//999 闭包的概念我们将像f2函数这样，能够读取其他函数内部变量的函数，称之为闭包由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”外部通过f2函数访问到f1内部的变量，可见闭包是沟通外部和内部之间的桥梁 闭包的用途、闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。怎么理解始终存在内存？ 1234567function f1()&#123; var n=999; alert(n++); &#125;f1()//999f1()//999f1()//999 f1每次调用结束后 变量n会被清除，不会保存在内存中 1234567891011function f1()&#123; var n=999; function f2()&#123; alert(n++); &#125; return f2; &#125; var result=f1(); result()//999 result()//1000 result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。 为什么会这样呢？ 原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。 垃圾回收机制在Javascript中，如果一个对象不再被引用，那么这个对象就会被GC回收。如果两个对象互相引用，而不再被第3者所引用，那么这两个互相引用的对象也会被回收。因为函数f1被f2引用，f2又被f1外的result引用，这就是为什么函数f1执行后不会被回收的原因。那么我们来想象另一种情况，如果f1返回的不是函数f2，情况就完全不同了。因为f1执行完后，f2没有被返回给f1的外界，只是被f1所引用，而此时f1也只会被f2引 用，因此函数f1和f2互相引用但又不被外界打扰(被外界引用)，函数f1和f2就会被GC回收123456789function f1()&#123; var n=999; function f2()&#123; alert(n++); &#125; f2(); &#125; f1()//999 f1()//999 使用闭包的注意点1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery.event兼容各浏览器的event详细解析]]></title>
      <url>http://yoursite.com/2016/10/25/event/</url>
      <content type="text"><![CDATA[jQuery在遵循W3C规范的情况下，对事件的常用属性进行了封装，使得事件处理在各大浏览器下都可以正常的运行而不需要进行浏览器类型判断,如果想了解如何封装，可以看jquery源码 event对象的各个属性介绍jQuery的一个方法 jQuery.event.fix(event || window.event);此方法个浏览器的event对象转换为 jQuery.event; 如果您的事件是通过jQuery方法绑定的，就不需要进行转换了！ 1.event.type属性该方法作用是可以获取到时间的类型代码如下:1234$(&quot;a&quot;).click(function(event)&#123; alert(event.type); //获取时间类型 return false; //阻止链接跳转&#125;) 以上代码运行后会返回：“click”。 2.event.preventDefault()方法该方法的作用是阻止默认的事件行为。JavaScript中符合W3C规范的preventDefault()方法在IE浏览器中无效。jQuery对其进行了封装，使之能兼容各种浏览器。 3.event.stopPropagation()方法该方法是阻止事件的冒泡。JavaScript中符合W3C规范的stopPropagation()方法在IE浏览器中无效。jQuery对其进行封装，使之能兼容各种浏览器。 4.event.target属性event.target属性的作用是获取到出发事件的元素。jQuery对其封装后，避免了W3C、IE和safari浏览器不同标准的差异。代码如下:1234$(&quot;a[href=http://www.jb51.net]&quot;).click(function(event)&#123; alert(event.target.href); //获取触发事件的&lt;a&gt;元素的href属性值 alert(event.target.tagName); //获取触发事件的元素的标签名称 return false; //阻止链接跳转&#125;) 5.event.relatedTarget属性在标准DOM中，mouseover和mouseout所发生的元素可以通过event.target()方法来访问，相关元素是通过event.relatedTarget属性来访问的。event.relatedTarget属性在mouseover中相当于的event.fromElement属性，在mouseout中相当于event.toElement,jQuery对其进行了封装，使之能兼容各种浏览器。 6.event.pageX/event.pageY属性该方法的作用是获取到光标相对页面的x坐标和y坐标。如果没有使用jQuery时，那么IE浏览器中是用event/event.y方法，而在Firefox浏览器中用event.pageX/event.pageY方法。如果页上有滚动条，则还要加上滚动条的宽度和高度。在IE浏览器中还应该减去默认的2px的边框。代码如下:1234567$(function() &#123; $(&quot;a&quot;).click(function(event) &#123; alert(&quot;Current mouse position:&quot; + event.pageX + &quot;,&quot; + event.pageY); //获取鼠标当前相对于页面的坐标 return false; //阻止链接跳转 &#125;);&#125;) 7.event.which属性该方法的作用是在鼠标单击事件中获取到鼠标的左、中、右键；在键盘事件中获取键盘的按钮。 代码如下:12345$(function() &#123; $(&quot;body&quot;).mousedown(function(e) &#123; alert(e.which); //1 = 鼠标左键；2 = 鼠标中键；3 = 鼠标右键。 &#125;)&#125;) 以上代码加载到页面中，用鼠标单击页面时，单击左、中、右键分别返回1、2、3. 8.event.metaKey属性针对不同浏览器对键盘中的按键解释不同，jQuery也进行了封装，并规定event.metaKey()方法为键盘事件中获取按键。 9.event.originalEvent属性。该方法的作用是指向原始的事件对象。 事件的传播传播的三个阶段当一个事件发生以后，它会在不同的DOM节点之间传播（propagation）。这种传播分成三个阶段： 1.第一阶段：从window对象传导到目标节点，称为“捕获阶段”（capture phase）。2.第二阶段：在目标节点上触发，称为“目标阶段”（target phase）。3.第三阶段：从目标节点传导回window对象，称为“冒泡阶段”（bubbling phase）。这种三阶段的传播模型，会使得一个事件在多个节点上触发。比如，假设div节点之中嵌套一个p节点。123&lt;div&gt; &lt;p&gt;Click Me&lt;/p&gt;&lt;/div&gt; 如果对这两个节点的click事件都设定监听函数，则click事件会被触发四次。12345678910111213141516var phases = &#123; 1: &apos;capture&apos;, 2: &apos;target&apos;, 3: &apos;bubble&apos;&#125;;var div = document.querySelector(&apos;div&apos;);var p = document.querySelector(&apos;p&apos;);div.addEventListener(&apos;click&apos;, callback, true);//true 代表在事件捕获阶段触发 false 代表事件在冒泡阶段触发 默认为falsep.addEventListener(&apos;click&apos;, callback, true);//jquery封装的事件默认冒泡阶段捕获div.addEventListener(&apos;click&apos;, callback, false);p.addEventListener(&apos;click&apos;, callback, false);function callback(event) &#123; var tag = event.currentTarget.tagName; var phase = phases[event.eventPhase]; console.log(&quot;Tag: &apos;&quot; + tag + &quot;&apos;. EventPhase: &apos;&quot; + phase + &quot;&apos;&quot;);&#125; 事件代理常用于为后追加的元素绑定事件由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理（delegation）。123456var ul = document.querySelector(&apos;ul&apos;);ul.addEventListener(&apos;click&apos;, function(event) &#123;if (event.target.tagName.toLowerCase() === &apos;li&apos;) &#123; // some code&#125;&#125;); 上面代码的click事件的监听函数定义在ul节点，但是实际上，它处理的是子节点li的click事件。这样做的好处是，只要定义一个监听函数，就能处理多个子节点的事件，而且以后再添加子节点，监听函数依然有效。如果希望事件到某个节点为止，不再传播，可以使用事件对象的stopPropagation方法。 123p.addEventListener(&apos;click&apos;, function(event) &#123; event.stopPropagation();&#125;); 使用上面的代码以后，click事件在冒泡阶段到达p节点以后，就不再向上（父节点的方向）传播了。 但是，stopPropagation方法不会阻止p节点上的其他click事件的监听函数。如果想要不再触发那些监听函数，可以使用stopImmediatePropagation方法。1234567p.addEventListener(&apos;click&apos;, function(event) &#123; event.stopImmediatePropagation();&#125;);p.addEventListener(&apos;click&apos;, function(event) &#123; // 不会被触发&#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[$.extend详解]]></title>
      <url>http://yoursite.com/2016/10/24/$.extend/</url>
      <content type="text"><![CDATA[jQuery.extend()函数用于将一个或多个对象的内容合并到目标对象。该函数可以将一个或多个对象的成员属性和方法复制到指定的对象上。该函数属于全局jQuery对象。 静态函数jQuery.extend()有以下两种用法：用法一：jQuery 1.0 新增该用法。 1jQuery.extend( target [, object1 ] [, objectN... ] ) 用法二：jQuery 1.1.4 新增该用法。 1jQuery.extend( [ deep ], target , object1 [, objectN... ] ) 用法二是用法一的变体，参数deep用于指示是否深度递归合并。$.extend() 打印出的值也是target的值 参数请根据前面语法部分所定义的参数名称查找对应的参数。 参数 描述 deep deep可选/Boolean类型指示是否深度合并对象，默认为false。如果该值为true，且多个对象的某个同名属性也都是对象，则该”属性对象”的属性也将进行合并。 targetObject targetObject类型目标对象，其他对象的成员属性将被复制到该对象上。 object1 object1可选/Object类型第一个被合并的对象。 objectN objectN可选/Object类型第N个被合并的对象。 注意事项 ● 该函数复制的对象属性包括方法在内。此外，还会复制对象继承自原型中的属性(JS内置的对象除外) 。 ● 参数deep的默认值为false，你可以为该参数明确指定true值，但不能明确指定false值。简而言之，第一个参数不能为false值。 ● 如果参数为null或undefined，则该参数将被忽略。 ● 如果只为$.extend()指定了一个参数，则意味着参数target被省略。此时，target就是jQuery对象本身。通过这种方式，我们可以为全局对象jQuery添加新的函数。 ● 如果多个对象具有相同的属性，则后者会覆盖前者的属性值。 实例用法一 实例 常见用法 如果多个被合并对象有相同的属性，则后者会覆盖之前的属性。 用法 二 此外，如果多个对象的同名属性都是对象，则合并这些”属性对象”的属性]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[cookie使用总结]]></title>
      <url>http://yoursite.com/2016/10/21/cookie/</url>
      <content type="text"><![CDATA[cookie 一个轻量级的cookie 插件，可以读取、写入、删除 cookie。 jquery.cookie.js 的配置首先包含jQuery的库文件，在后面包含 jquery.cookie.js 的库文件。 使用方法1.新添加一个会话 cookie：$.cookie(‘the_cookie’, ‘the_value’);注：当没有指明 cookie有效时间时，所创建的cookie有效期默认到用户关闭浏览器为止，所以被称为“会话cookie（session cookie）”。2.创建一个cookie并设置有效时间为 7天:$.cookie(‘the_cookie’, ‘the_value’, { expires: 7 });注：当指明了cookie有效时间时，所创建的cookie被称为“持久 cookie （persistent cookie）”。3.创建一个cookie并设置 cookie的有效路径：$.cookie(‘the_cookie’, ‘the_value’, { expires: 7, path: ‘/‘ });注：在默认情况下，只有设置 cookie的网页才能读取该 cookie。如果想让一个页面读取另一个页面设置的cookie，必须设置cookie的路径。cookie的路径用于设置能够读取 cookie的顶级目录。将这个路径设置为网站的根目录，可以让所有网页都能互相读取 cookie （一般不要这样设置，防止出现冲突） 。4.读取cookie：$.cookie(‘the_cookie’); // cookie存在 =&gt; ‘the_value’$.cookie(‘not_existing’); // cookie不存在 =&gt; null5.删除cookie，通过传递null作为cookie的值即可 ：$.cookie(‘the_cookie’, null); ———-相关参数的解释————— 1).expires: 365定义cookie的有效时间，值可以是一个数字（从创建cookie时算起，以天为单位）或一个Date 对象。如果省略，那么创建的cookie是会话cookie，将在用户退出浏览器时被删除。2).path: ‘/‘默认情况：只有设置cookie的网页才能读取该cookie。定义cookie的有效路径。默认情况下， 该参数的值为创建 cookie 的网页所在路径（标准浏览器的行为） 。如果你想在整个网站中访问这个cookie需要这样设置有效路径：path: ‘/‘。如果你想删除一个定义 了有效路径的 cookie，你需要在调用函数时包含这个路径: $.cookie(‘the_cookie’, null,{ path: ‘/‘ });。domain: ‘example.com’默认值：创建 cookie的网页所拥有的域名。3).secure: true默认值：false。如果为true，cookie的传输需要使用安全协议（HTTPS）。4).raw: true默认值：false。默认情况下，读取和写入 cookie 的时候自动进行编码和解码（使用encodeURIComponent 编码，decodeURIComponent 解码）。要关闭这个功能设置 raw: true 即可。 引自：http://wenku.baidu.com/view/0147277e27284b73f2425074.html 代码：http://files.cnblogs.com/Denny_Yang/jquery.cookie.js 当cookie设置了除了0以外的具体时间的时候，小于0，这个cookie直接就过期，大于0，那就等到这个时间之后，cookie过期，不论其是否关闭浏览器cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案 cookie 和session 的区别：1、cookie数据存放在客户的浏览器上，session数据放在服务器上。2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗 考虑到安全应当使用session。3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能 考虑到减轻服务器性能方面，应当使用COOKIE。4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。5、所以个人建议： 将登陆信息等重要信息存放为SESSION 其他信息如果需要保留，可以放在COOKIE中知乎：1.因为http是无状态的,每次请求都是 一个独立过程,所以下一次请求无法得知上一次请求产生的一些数据因此产生了cookie,作用是在一次请求介绍后保存一些数据到客户端,客户端在下次请求时携带上这些数据来确定状态；2.session是一般基于cookie的(session id也可以通过url参数进行传递),原理是通过cookie在客户端保存一个唯一身份识别id然后再服务器内存或者数据库中对这个唯一身份进行关联,每次请求过来的时候通过这个id从内存或者数据库中取出相应数据;3,session id在客户端可以通过cookie或者get post 参数,或者url地址的形式进行传递(只要与服务器进行约定方法非常多)默认是通过cookie实现的；在服务器上session可以通过内存,文件,数据库等形式进行保存(java web中默认是存在内存中,django默认是存在数据库中,尚未发现存在文件中的) 1234567891011session&lt;?phpsession_start();if(isset($_SESSION[&apos;views&apos;])) $_SESSION[&apos;views&apos;]=$_SESSION[&apos;views&apos;]+1;else $_SESSION[&apos;views&apos;]=1;echo &quot;Views=&quot;. $_SESSION[&apos;views&apos;];?&gt; localstorageHTML5中提供了localStorage对象可以将数据长期保存在客户端，直到人为清除。localStorage提供了几个方法:1、存储：localStorage.setItem(key,value)如果key存在时，更新value2、获取：localStorage.getItem(key)如果key不存在返回null3、删除：localStorage.removeItem(key)一旦删除，key对应的数据将会全部删除4、全部清除：localStorage.clear()某些时候使用removeItem逐个删除太麻烦，可以使用clear,执行的后果是会清除所有localStorage对象保存的数据5、遍历localStorage存储的key.length 数据总量，例：localStorage.length.key(index) 获取key，例：var key=localStorage.key(index);6、存储JSON格式数据JSON.stringify(data) 将一个对象转换成JSON格式的数据串,返回转换后的串JSON.parse(data) 将数据解析成对象，返回解析后的对象备注：localStorage存数的数据是不能跨浏览器共用的，一个浏览器只能读取各自浏览器的数据,储存空间5M 。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Javascript 高级程序设计]]></title>
      <url>http://yoursite.com/2016/10/21/note/</url>
      <content type="text"><![CDATA[Javascript 高级程序设计 记录下读书心得 javascript简介 javascript 由三部分组成ECMAscript Dom（文档对象模型） Bom（浏览器对象模型） 在HTML中使用javascriptscriptscript标签 6个属性 async 表示应该立即下载脚本，但不应妨碍页面中的其他操作，比如下载其他资源或等待加载其他脚本。只对外部脚本文件有效。 charset defer 表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效 language 已弃用 src 包含要执行的外部文件 type ，目前type 属性的值依旧还是text/javascript。不过，这个属性并不是必需的，如果没有指定这个属性，则其默认值仍为text/javascript。 使用script元素的方式有两种：直接在页面中嵌入JavaScript 代码和包含外部JavaScript文件 在使用script嵌入JavaScript 代码时，记住不要在代码中的任何地方出现”/script”字符串，通过转义字符“/”可以解决这个问题 12345678910xhtml可以省略&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;example.js&quot; /&gt;html不可以省略&lt;script type=&quot;text/javascript&quot; src=&quot;example.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;example.js&quot;&gt;console.log(&quot;1&quot;);&lt;/script&gt;带有src 属性的&lt;script&gt;元素不应该在其&lt;script&gt;和&lt;/script&gt;标签之间再包含额外的JavaScript 代码。如果包含了嵌入的代码，则只会下载并执行外部脚本文件，嵌入的代码会被忽略。 通过script便签元素的src 属性还可以包含来自外部域的JavaScript 文件。这一点既让script元素倍显强大，又让它备受争议。在这一点上，script与img元素非常相似，即它的src属性可以是指向当前HTML 页面所在域之外的某个域中的完整URL 在script元素中设置defer 属性，相当于告诉浏览器立即下载，但延迟执行。 同样与defer 类似，async 只适用于外部脚本文件，都是用来改变脚本，并告诉浏览器立即下载文件。但与defer不同的是，标记为async 的脚本并不保证按照指定它们的先后顺序执行 文档类型HTML 也有多个不同的版本，只有完全明白页面中使用的确切 HTML 版本，浏览器才能完全正确地显示出 HTML 页面。这就是 &lt;!DOCTYPE&gt; 的用处。 &lt;!DOCTYPE&gt; 不是 HTML 标签。它为浏览器提供一项信息（声明），即 HTML 是用什么版本编写的。 文档模式http://www.cnblogs.com/venoral/p/5317824.html最初是 混杂模式和标准模式 IE 又提出一种所谓的准标准模式准标准模式与标准模式非常接近，它们的差异几乎可以忽略不计虽然这两种模式主要影响CSS内容的呈现，但在某些情况下也会影响到JavaScript 的解释执行 如果在文档开始处没有发现文档类型声明，则所有浏览器都会默认开启混杂模式。但采用混杂模式不是什么值得推荐的做法，因为不同浏览器在这种模式下的行为差异非常大 对于准标准模式，则可以通过使用过渡型（transitional）或框架集型（frameset）文档类型来触发 基本概念数据类型typeofNumber String Boolean Null undefined Null空对象指针 typeof(null) //object如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为null 而不是其他值var c=null;这样做不仅可以体现null 作为空对象指针的惯例，而且也有助于进一步区分null 和undefined。null==undefined //true undefined声明但未初始化的变量 Boolean各种值转换为boolean值的情况,解释了if() 转换过程 输入值 示例 返回值 0 Boolean(0) false NaN Boolean(NaN) false 数字（非 0 或 NaN） Boolean(4) true 空字符串 Boolean(“”) false 非空字符串 Boolean(“6”) true null Boolean(null) false undefined Boolean(undefined) false Object 类的实例 Boolean(new Object()) true 无参数 Boolean() false NumberNaN 非数字,NaN 本身有两个非同寻常的特点。首先，任何涉及NaN 的操作（例如NaN/10）都会返回NaN，这个特点在多步计算中有可能导致问题。其次NaN 与任何值都不相等，包括NaN 本身 isNaN() 是非数字isNaN()在接收到一个值之后，会尝试将这个值转换为数值。某些不是数值的值会直接转换为数值，例如字符串”10”或Boolean 值。而任何不能被转换为数值的值都会导致这个函数返回true 12345alert(isNaN(NaN)); //truealert(isNaN(10)); //false（10 是一个数值）alert(isNaN(&quot;10&quot;)); //false（可以被转换成数值10）alert(isNaN(&quot;blue&quot;)); //true（不能转换成数值）alert(isNaN(true)); //false（可以被转换成数值1） 数值转换有3 个函数可以把非数值转换为数值：Number()、parseInt()和parseFloat()。第一个函数，即转型函数Number()可以用于任何数据类型，而另两个函数则专门用于把字符串转换成数值 Number()函数的转换规则如下。 如果是Boolean 值，true 和false 将分别被转换为1 和0。 如果是数字值，只是简单的传入和返回。 如果是null 值，返回0 。 如果是undefined，返回NaN。 如果是字符串，遵循下列规则： 如果字符串中只包含数字（包括前面带正号或负号的情况），则将其转换为十进制数值，即”1” 会变成1，”123”会变成123，而”011”会变成11（注意：前导的零被忽略了）； 如果字符串中包含有效的浮点格式，如”1.1”，则将其转换为对应的浮点数值（同样，也会忽略前导零）； 如果字符串中包含有效的十六进制格式，例如”0xf”，则将其转换为相同大小的十进制整数值； 如果字符串是空的（不包含任何字符），则将其转换为0； 如果字符串中包含除上述格式之外的字符，则将其转换为NaN。 如果是对象，则调用对象的valueOf()方法，然后依照前面的规则转换返回的值。如果转换的结果是NaN，则调用对象的toString()方法，然后再次依照前面的规则转换返回的字符串值。 1234var num1 = Number(&quot;Hello world!&quot;); //NaNvar num2 = Number(&quot;&quot;); //0var num3 = Number(&quot;000011&quot;); //11var num4 = Number(true); //1 一般在处理字符串转换为数字 使用parseInt更合理 1.它会忽略字符串前面的空格，直至找到第一个非空格字符。如果第一个字符不是数字字符或者负号，parseInt()就会返回NaN,也就是说，用parseInt()转换空字符串会返回NaN（Number()对空字符返回0）。 2.如果第一个字符是数字字符，parseInt()会继续解析第二个字符，直到解析完所有后续字符或者遇到了一个非数字字符。例如，”1234blue”会被转换为1234，因为”blue”会被完全忽略。类似地，”22.5”会被转换为22，因为小数点并不是有效的数字字符。 3.如果字符串中的第一个字符是数字字符，parseInt()也能够识别出各种整数格式（十进制、八进制和十六进制数）。也就是说，如果字符串以”0x”开头且后跟数字字符，就会将其当作一个十六进制整数；如果字符串以”0”开头且后跟数字字符，则会将其当作一个八进制数来解析。 1234567891011121314var num1 = parseInt(&quot;1234blue&quot;); // 1234var num2 = parseInt(&quot;&quot;); // NaNvar num3 = parseInt(&quot;0xA&quot;); // 10（十六进制数）var num4 = parseInt(22.5); // 22var num5 = parseInt(&quot;070&quot;); // 56（八进制数）var num6 = parseInt(&quot;70&quot;); // 70（十进制数）var num7 = parseInt(&quot;0xf&quot;); // 15（十六进制数）指定基数会影响到转换的输出结果。例如：var num1 = parseInt(&quot;10&quot;, 2); //2 （按二进制解析）var num2 = parseInt(&quot;10&quot;, 8); //8 （按八进制解析）var num3 = parseInt(&quot;10&quot;, 10); //10 （按十进制解析）var num4 = parseInt(&quot;10&quot;, 16); //16 （按十六进制解析） 与parseInt()函数类似，parseFloat()也是从第一个字符（位置0）开始解析每个字符。而且也是一直解析到字符串末尾，或者解析到遇见一个无效的浮点数字字符为止。也就是说，字符串中的第一个小数点是有效的，而第二个小数点就是无效的了， 123456var num1 = parseFloat(&quot;1234blue&quot;); //1234 （整数）var num2 = parseFloat(&quot;0xA&quot;); //0var num3 = parseFloat(&quot;22.5&quot;); //22.5var num4 = parseFloat(&quot;22.34.5&quot;); //22.34var num5 = parseFloat(&quot;0908.5&quot;); //908.5var num6 = parseFloat(&quot;3.125e7&quot;); //31250000 String 字符字面量比如/n /t字符字面量可以出现在字符串中的任意位置，而且也将被作为一个字符来解析 12var text = &quot;This is the letter sigma: \u03a3.&quot;;alert(text.length); // 输出28 2.，字符串一旦创建，它们的值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量 这个过程是在后台发生的，而这也是在某些旧版本浏览器（例如版本低于1.0 的Firefox、IE6 等 间接解释了push效率高于+连接字符串）中拼接字符串时速度很慢的原因所在。但这些浏览器后来的版本已经解决了这个低效率问题。 3.转换字符串数值、布尔值、对象和字符串值（没错，每个字符串也都有一个toString()方法，该方法返回字符串的一个副本）都有toString()方法。但null 和undefined 值没有这个方法。 1234567数值调用toString() 可传递一个基数var num = 10;alert(num.toString()); // &quot;10&quot;alert(num.toString(2)); // &quot;1010&quot;alert(num.toString(8)); // &quot;12&quot;alert(num.toString(10)); // &quot;10&quot;alert(num.toString(16)); // &quot;a&quot; String()函数遵循下列转换规则： 如果值有toString()方法，则调用该方法（没有参数）并返回相应的结果； 如果值是null，则返回”null”； 如果值是undefined，则返回”undefined”。 ObjectObject 的每个实例都具有下列属性和方法。 constructor：保存着用于创建当前对象的函数。对于前面的例子而言，构造函数（constructor）就是Object()。 hasOwnProperty(propertyName)：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名（propertyName）必须以字符串形式指定（例如：o.hasOwnProperty(“name”)）。 isPrototypeOf(object)：用于检查传入的对象是否是传入对象的原型（第5 章将讨论原型）。 propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用for-in 语句（本章后面将会讨论）来枚举。与hasOwnProperty()方法一样，作为参数的属性名必须以字符串形式指定。 toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应。 toString()：返回对象的字符串表示。 valueOf()：返回对象的字符串、数值或布尔值表示。通常与toString()方法的返回值相同。 123456789101112function car()&#123;this.name=&apos;sbx&apos;;this.age=&quot;1234&quot;&#125;var car1=new car()car.prototype.sex=&quot;nv&quot;car1.constructor//car()&#123;this.name=&apos;sbx&apos;;this.age=&quot;1234&quot;&#125;car1.hasOwnProperty(&quot;name&quot;)//truecar1.hasOwnProperty(&quot;sex&quot;)//falsecar.prototype.isPrototypeOf(car1)//truecar1.propertyIsEnumerable(&quot;age&quot;)//truecar1.propertyIsEnumerable(&quot;sex&quot;)//falsecar1.toLocaleString()//&quot;[object Object]&quot;car1.toString()//&quot;[object Object]&quot;car1.valueOf()//car &#123;name: &quot;sbx&quot;, age: &quot;1234&quot;&#125; 操作符相等操作符相等和不相等——先转换再比较，全等和不全等——仅比较而不转换。 == 和=== 对比 == 相等（转换值比较）=== 全等（值和类型都要比较）=== 类型不同 就不相等 ，有一个值为NaN 也不相等 – – – — — == -0==0 true 1==true true 5==’5’ true null==undefined true === -0===0 true 1===true false 5===’5’ false null===undefined false 语句for-in 枚举对象的属性 break 和continue 语句用于在循环中精确地控制代码的执行。其中，break 语句会立即退出循环，强制继续执行循环后面的语句。而continue 语句虽然也是立即退出循环，但退出循环后会从循环的顶部继续执行 1234567891011121314151617181920212223242526var num = 0;for (var i=1; i &lt; 10; i++) &#123;if (i % 5 == 0) &#123;continue;&#125;num++;console.log(i+&quot; &quot;+num);&#125;2016-10-24 17:25:25.549 VM11823:6 1 12016-10-24 17:25:25.550 VM11823:6 2 22016-10-24 17:25:25.551 VM11823:6 3 32016-10-24 17:25:25.551 VM11823:6 4 42016-10-24 17:25:25.552 VM11823:6 6 52016-10-24 17:25:25.552 VM11823:6 7 62016-10-24 17:25:25.552 VM11823:6 8 72016-10-24 17:25:25.555 VM11823:6 9 8var num = 0;for (var i=1; i &lt; 10; i++) &#123;if (i % 5 == 0) &#123;break;&#125;num++;console.log(i+&quot; &quot;+num);&#125;2016-10-24 17:27:22.372 VM11824:6 1 12016-10-24 17:27:22.372 VM11824:6 2 22016-10-24 17:27:22.372 VM11824:6 3 32016-10-24 17:27:22.373 VM11824:6 4 4]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Backbone]]></title>
      <url>http://yoursite.com/2016/10/20/backbone/</url>
      <content type="text"><![CDATA[Backbone 是一个 JavaScript 框架，可用于创建模型-视图-控制器 (model-view-controller, MVC) 类应用程序和单页界面 事件管理Backbone.Events 通过继承Events的方法来实现事件的管理 它是Backbone的核心组成的部分 基本事件方法绑定on方法 使用on方法监听默认事件 使用on方法监听属性事件 使用on方法获取属性修改前的值 使用on方法绑定多个事件 绑定once方法once()执行一次 trigger 触发事件 off（）移除事件 新增事件方法监听事件listenTo监听一次listenToOnce（）停止监听stopListening 特殊事件的使用特殊事件all的使用事件与View Model和Collection的关系 数据模型Model.extend()可以创建数据模型1.实例化过程中自动执行initializa函数 var Student=Backbone.Model.extend({ initialize:function(){ intnum++; console.log(&quot;您已经创建了&quot;+intnum+&quot;个对象&quot;); } }); var intnum=0; var stuA=new Student();//实例化过程中自动执行initialize函数 var stuB=new Student(); //您已经创建了2个对象 2.对象模型赋值方法 通过defaults设置默认值 实例化的对象 可以通过obj.set()设置对象属性值 3.可以通过obj.get() obj.escape()获取属性值4.监听属性值的变化5.自定义模型中的方法 var Student=Backbone.Model.extend({ initialize:function(){ this.on(&quot;change:name&quot;,function(model,value){ // var oldname=this.previous(&quot;name&quot;); var oldname=model.previous(&quot;name&quot;); // var newname1=this.get(&quot;name&quot;); var newname1=value; console.log(&quot;旧值是&quot;+oldname+&quot;,新值是&quot;+newname1); }) }, defaults:{ name:&quot;zhangsan&quot;, age:&quot;13&quot; }, PrintLog:function(){ console.log(this.get(&quot;name&quot;)+this.get(&quot;age&quot;)); } }); var stu=new Student(); stu.set({ name:&quot;lisi&quot;, age:&quot;14&quot; }); stu.PrintLog(); 模型对象操作 读取修改数据 验证 关闭验证在使用set()设置或修改属性 必须将validate的属性值设置为true 来通知backbone框架开启验证调用validate（）方法 按照里边的规则对相应数据进行验证（有一处数据不符合规则即为验证失败，设置也会失败），验证失败，触发invalid方法，返回失败的原因显示在浏览器。 var Teacher=Backbone.Model.extend({ initialize:function(){ this.on(&quot;invalid&quot;,function(model,error){ console.log(error); }); }, validate:function(arr){ if(!_.isString(arr.name)){ return &apos;姓名不是字符串&apos;; } }, defaults:{ &quot;name&quot;:&quot;sunbaixin&quot;, &quot;age&quot;:&quot;34&quot;, &quot;score&quot;:&quot;89&quot; } }); var tea=new Teacher(); tea.set({ name:789, age:90 },{validate:&quot;true&quot;}); console.log(tea.toJSON()); 输出结果： 姓名不是字符串 Object {name: &quot;sunbaixin&quot;, age: &quot;34&quot;, score: &quot;89&quot;} 3 更新数据回滚 silent：true4 删除数据 obj.unset(属性名) obj.clear()没有参数 全部清除 对象属性操作1 调用attributes对象获取所有的属性值 2 调用previous()和previousAttributes()方法 返回对象修改前上一个状态的属性值 var StudentA=Backbone.Model.extend({ initialize:function(){ }, defaults:{ name:&quot;zhangsan&quot;, age:&quot;13&quot; } }); var stuA=new StudentA(); stuA.set({ name:&quot;lisi&quot;, age:&quot;14&quot; }); var arr=stuA.attributes; for(var i in arr){ console.log(i+&quot;:&quot;+arr[i]); }//name:lisi age:14 console.log(stuA.previous(&quot;name&quot;));//zhangsan console.log(stuA.previousAttributes());//Object {name: &quot;zhangsan&quot;, age: &quot;13&quot;} 同步数据到服务器在Backbone中 客户端静态页和服务器上的数据可以通过save fetch destroy等方法对服务器上的数据进行保存 获取删除等操作 模型集合自定义模型集合 var Student=Backbone.Model.extend({ defaults:{ name:&quot;sbx&quot;, code:&quot;34&quot; } }); var Stus=Backbone.Collection.extend({ model:Student, good:function(){ return this.filter(function(stu){ return stu.get(&quot;code&quot;)&gt;78}); } }) var stulist=[{ name:&quot;lidong1&quot;, code:89 },{ name:&quot;lidong2&quot;, code:78 },{ name:&quot;lidong3&quot;, code:79 }]; var stu=new Stus(stulist); var stug=stu.good(); for(var i=0;i&lt;stug.length;i++){ console.log(stug[i].toJSON()); } 操作集合中模型对象 添加 add unshift push 删除 pop shift remove 排序 sort 查找 get(id) 通过指定id获取集合中某一个集合对象 at(index) 通过指定索引号 获取集合中某一个集合对象 findWhere（attr）查找匹配的属性名称和属性值的第一个集合对象 where（attr，first) first为true 查找匹配的属性名称和属性值的第一个集合对象 first为false 查找匹配的属性名称和属性值的所有集合对象 var Student=Backbone.Model.extend({ defaults:{ name:&quot;sbx&quot;, code:&quot;34&quot; }, idAttribute:&quot;code&quot; }; var Stus=Backbone.Collection.extend({ model:Student }) var stulist=[{ name:&quot;lidong1&quot;, code:89 },{ name:&quot;lidong3&quot;, code:78 },{ name:&quot;lidong3&quot;, code:79 },{ name:&quot;lidong4&quot;, code:79 }]; var newdata=[{ name:&quot;lidong5&quot;, code:89 },{ name:&quot;lidong6&quot;, code:78 },{ name:&quot;lidong7&quot;, code:77 }]; var stu=new Stus(stulist); console.log(stu.get(79).toJSON()); console.log(stu.at(0).toJSON()); var find_model1=stu.findWhere({ code:79 }); console.log(find_model1.toJSON()); var find_model2=stu.where({ name:&quot;lidong3&quot; },false); for(var i=0;i&lt;find_model2.length;i++){ console.log(find_model2[i].toJSON()); } // console.log(stu.shift()); // console.log(stu.remove(stu.models[0])) // console.log(stu.pop()); // stu.push(newdata[0]) for(var i=0;i&lt;stu.models.length;i++){ console.log(stu.models[i].toJSON()); }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[sass]]></title>
      <url>http://yoursite.com/2016/10/20/sass/</url>
      <content type="text"><![CDATA[sass入门]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[php]]></title>
      <url>http://yoursite.com/2016/10/20/php/</url>
      <content type="text"><![CDATA[PHP PHP 是一种创建动态交互性站点的强有力的服务器端脚本语言。PHP 能够做什么？ PHP 能够生成动态页面内容 PHP 能够创建、打开、读取、写入、删除以及关闭服务器上的文件 PHP 能够接收表单数据 PHP 能够发送并取回 cookies PHP 能够添加、删除、修改数据库中的数据 PHP 能够限制用户访问网站中的某些页面 PHP 能够对数据进行加密 通过 PHP，您可以不受限于只输出 HTML。您还能够输出图像、PDF 文件、甚至 Flash 影片。您也可以输出任何文本，比如 XHTML 和 XML。 PHP基础语法PHP 脚本在服务器上执行，然后向浏览器发送回纯 HTML 结果。 1. PHP 脚本可放置于文档中的任何位置。PHP 脚本以 &lt;?php 开头，以 ?&gt; 结尾： 注释：PHP 语句以分号结尾（;）。PHP 代码块的关闭标签也会自动表明分号（因此在 PHP 代码块的最后一行不必使用分号）。 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;h1&gt;我的第一张 PHP 页面&lt;/h1&gt; &lt;?php echo &quot;Hello World!&quot;; ?&gt; &lt;/body&gt; &lt;/html&gt; 2 支持三种注释方式 3 变量对大小写敏感 PHP 变量规则： 变量以 $ 符号开头，其后是变量的名称 变量名称必须以字母或下划线开头 变量名称不能以数字开头 变量名称只能包含字母数字字符和下划线（A-z、0-9 以及 _） 变量名称对大小写敏感（$y 与 $Y 是两个不同的变量） 4 向浏览器输出 echo（） printf（） 5 PHP数据类型 标量数据类型 布尔型 整型 浮点型 字符型 符合数据类型：数组 对象 6 强制类型转换 （array）（bool）或（boolean）（int）或（integer）（object）（real）或（double）或（float）（string） 7 类型自动转换 8 与类型有关的函数 gettypesettype 9 类型标识符函数 标识符 10 变量作用域 局部变量 函数参数 全局变量 静态变量（函数退出时不会丢失值） $_SERVER 11 表达式 逻辑 比较 位操作都与js类似 拼接符不同 字符串拼接符（.) 拼接赋值操作符（.=) $a=&apos;abc&apos;.&apos;def&apos;;//abcdef $a=&apos;abc&apos;+&apos;def&apos;//0 +是赋值操作符 12 字符串插入 双引号扩起的字符串 变量和转义序列都会得到相应的解析 单引号 变量和转义序列都不会得到解析 $a=”abc”.”def”; echo “this is $a”;//this is abcdef echo ‘this is $a’;//this is $a 函数1 &lt;?php $total=22; $cost=4; function calcute(&amp;$total,$cost){ $total=$total+$cost; $cost+=4; } calcute($total,$cost); echo($total.&quot; &quot;.$cost);//26,4 ?&gt; 按值传递参数（把实参的值 传递给形参 形参是实参的拷贝） 这就意味着，函数范围内对这些值的任意改变在函数外部都会被忽略 按引用传递参数（把实参的地址传递给形参， 形参和实参是同一个对象） 函数内对参数所做的改变都会体现在函数外 2 函数库 数组1 创建数组 array（item1，item2.....); $lang=array(&quot;English&quot;,&quot;Spanish&quot;); 关联数组 $lang=array(&quot;Spain&quot;=&gt;&quot;Spanish&quot;,&quot;United&quot;=&gt;&quot;English&quot;); 2 list()提取数组 range（）预定义范围的值填充数组 3 测试数组 is_array() 4 输出数组foreach 5添加删除元素 array_unshift(array,mixed ele,....) array_push() array_shift() array_pop() 6 定位数组元素 搜索数组 in_array() 搜索特定值 array_key_exists() 找到指定的键 返回bool值 array_search() 搜索指定的值 返回相应的键 array_keys() 返回一个数组 包含所有的键 array_values()返回一个数组所有值，并提供索引值 7 遍历数组 key() 获取当前数组键 current()获取当前数组值 each（）返回数组的当前键值对 next（）向下移动数组指针 prev（）向上移动数组指针 reset（） end（） array_walk(array,callback()) eg:$fruits = array(&quot;d&quot;=&gt;&quot;lemon&quot;,&quot;a&quot;=&gt;&quot;orange&quot;,&quot;b&quot;=&gt;&quot;banana&quot;,&quot;c&quot;=&gt;&quot;apple&quot;); function test_print( $value,$key ) { echo &quot;$value&lt;br&gt;\n&quot;; echo &quot;$key&lt;br&gt;\n&quot;; } array_walk( $fruits, &apos;test_print&apos; ); 8 确定数组大小和唯一性 count（）返回数组中值的总数 array_unique() 删除所有重复值 返回由唯一值组成的数组 array_count_values() 统计数组元素出现的频度 9数组排序 array_reverse() 逆置数组元素顺序array_flip()置换数组键和值sort（）数组排序 10 合并 拆分 接合和分解数组array_merge() 面向对象的PHP1.oop :封装 继承 多态实例： &lt;?php class Site { /* 成员变量 */ var $url; var $title; function __construct( $par1, $par2 ) { $this-&gt;url = $par1; $this-&gt;title = $par2; } /* 成员函数 */ function setUrl($par){ $this-&gt;url = $par; } function getUrl(){ echo $this-&gt;url . PHP_EOL; } function setTitle($par){ $this-&gt;title = $par; } function getTitle(){ echo $this-&gt;title . PHP_EOL; } } $runoob = new Site(&apos;www.runoob.com&apos;, &apos;菜鸟教程&apos;); $taobao = new Site(&apos;www.taobao.com&apos;, &apos;淘宝&apos;); $google = new Site(&apos;www.google.com&apos;, &apos;Google 搜索&apos;); // 调用成员函数，获取标题和URL $runoob-&gt;getTitle(); $taobao-&gt;getTitle(); $google-&gt;getTitle(); $runoob-&gt;getUrl(); $taobao-&gt;getUrl(); $google-&gt;getUrl(); ?&gt; //变量 $this 代表自身的对象。 PHP_EOL 为换行符。 2.类 对象 属性 常量 方法 属性： public 任何位置都能访问 private 只能在类内部使用 不能由实例化的对象调用 也不能由类的子类使用 protected 只能在该类及其子类中使用 abstract final 标记为final的方法可以防止被子类覆盖 static 3 构造函数和析构函数 对象实例化的时候 自动执行构造函数 &lt;?php class Emplyee{ private $name; function __construct($Vname){ $this-&gt;setName($Vname); $this-&gt;getName(); } function setName($name){ $this-&gt;name=$name; } function getName(){ echo $this-&gt;name; } } $emply=new Emplyee(&quot;salary&quot;); ?&gt; 调用父类构造函数 function __construct(){ parent::__construct(); } 调用无关的构造函数 classname：：__construct() 析构函数 3 静态类成员 所有类实例共享的属性和方法 静态变量 是只存在于函数作用域的变量, 不过, 在函数执行完成后,这种变量的值不会丢失,也就是说, 在下一次调用这个函数时,变量仍然会记得原来的值. 要将某个变量定义为静态的, 只需要在变量前加上 static 关键字即可. 类中静态元素的使用在类中, static 关键字有两种主要用法, 一是用来定义静态成员,一是用来定义静态方法. 在类的内部, 可以使用作用域限定符 (::) 来访问不同层次作用域的变量. 静态成员 静态成员是一种类变量, 可以把它看成时属于整个类而不是属于类的某个实例. 与一般的实例变量不同的是, 静态成员只保留一个变量值, 而这个变量值对所有的实例都是有效的, 也就是说, 所有的实例共享这个成员. $this 只表示类的当前实例, 而 self:: 表示的是类本身,在类之外的代码中不能使用这个操作符,而且它不能识别自己在继承树层次结构中的位置. 也就是说, 在扩展类中使用self 作用域时, self 可以调用基类中声明的方法, 但它调用的总是已经在扩展类中重写的方法. 与$this 不同的是, 在使用静态变量时,必须在作用域限定符后面加上$符号.在扩展类中, 在基类的方法被重写的情况下,使用 parent 作用域调用定义在基类中的方法.静态成员也可以只属于父类. 如果在子类和父类中同时声明了某个成员,也可以使用parant:: 在子类中访问父类中的变量. 在这种情况下, 父类的静态成员和子类的静态成员保存的是不同的值. 可以在 :: 操作符的左边写上类的名称来静态地访问某个成员, 这样避免创建类的实例. 不仅省略掉实例化类的代码, 而且还会更高效, 因为类的每个实例都会占用一小部分的系统资源.在使用 :: 操作符访问成员变量时, 需要再次注意对$符号的使用. 因为PHP当前不支持动态的静态变量的使用, 也就是说不支持可变的静态变量. 在使用$this-&gt;$var时, 被访问的成员是包含在$var中的变量的值. 而不用$符号访问某个变量实际上查找的是类的某个常量, 而常量是不能通过$this来访问的. PHP6 中提出的static:: 作用域使我们不再需要使用self:: 和parent::. 当希望指向最终的实现功能的类时, 就可以使用static::, 这个限定符会在代码执行之前立即计算出继承层次机构上最后那个类的成员. 之一过程被称为延迟绑定, 它使我们可以在子类中重写某个静态变量, 并且也可以从某个在父类中声明的函数中反问这个最终成员. 静态方法 静态方法和非静态方法之间有一个重要的区别: 在调用静态方法时, 不再需要拥有类的实例. 静态方法和非静态方法使用原则:一是如果某个方法中不包含$this 变量, 就应该时静态方法; 如果不需要类的实例, 可能还应该使用静态类, 这样可以免去实例化类的工作. 另, 在静态方法中时不能使用$this 变量的, 因为静态方法不属于某个特定的实例. PHP中使用作用域限定操作符时, 用变量作为类的名称时不允许的.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[学习计划]]></title>
      <url>http://yoursite.com/2016/10/20/learn/</url>
      <content type="text"><![CDATA[学习规划1、js设计模式阅读了两本书 2、fis3学习使用(源码学习)初级使用已经完成实验 3、学习httphttp权威指南（完成） 4、MVC设计模式spane.js源码已经阅读 underscore.js源码看了90% 下一步研究backbone.js的使用 5、学习git学习更多的命令行（学习了20%） 学习开通github和博客（总结各种资源） doing.... 6、chrome devtools 使用有几个面板还不熟悉 7、学习node8、requirejs源码分析与使用9、jQuery源码分析10、学习React (+react ntive)11、ES612、构建工具* grunt * gulp * fis * webpack * rollup * browserfy 13、模块化esl.js require.js sea.js 14、vue.js]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jsonp]]></title>
      <url>http://yoursite.com/2016/10/20/jsonp/</url>
      <content type="text"><![CDATA[JSONP跨域原理解析 可参考JavaScript是一种在Web开发中经常使用的前端动态脚本技术。在JavaScript中，有一个很重要的安全性限制，被称为“Same-Origin Policy”（同源策略）。这一策略对于JavaScript代码能够访问的页面内容做了很重要的限制，即JavaScript只能访问与包含它的文档在同一域下的内容。 JavaScript这个安全策略在进行多iframe或多窗口编程、以及Ajax编程时显得尤为重要。根据这个策略，在baidu.com下的页面中包含的JavaScript代码，不能访问在google.com域名下的页面内容；甚至不同的子域名之间的页面也不能通过JavaScript代码互相访问。对于Ajax的影响在于，通过XMLHttpRequest实现的Ajax请求，不能向不同的域提交请求，例如，在abc.example.com下的页面，不能向def.example.com提交Ajax请求，等等 然而，当进行一些比较深入的前端编程的时候，不可避免地需要进行跨域操作，这时候“同源策略”就显得过于苛刻。JSONP跨域GET请求是一个常用的解决方案，下面我们来看一下JSONP跨域是如何实现的，并且探讨下JSONP跨域的原理。 举例说明写法一： 写法二： netwrok上查看接口如下 http://api.fang.58.com/phplocal/getshangquan/?jsoncallback=jQuery1800931218545883894_1463990648558&amp;cityid=1&amp;cateid=70134&amp;localid=1142&amp;_=1463990652773 Jsonp的执行过程如下：一.首先在客户端注册一个callback (默认名字为callback，用户可自定义名字如:’jsoncallback’，但要保证服务器能够查询到这个参数名) 说明：ajax内部的处理总的来分2大块 1.基于XMLHttpRequest的ajax请求 2.基于script的jsonp跨域请求 jquery源码（源码分析参考 )若想基于script的jsonp跨域请求，根据ajax传递的参数决定 首先看url上是否有callback=？（如jsoncallback=？就可以跨域请求，不管dataType参数值是什么）如果没有的话 会查看dataType的类型，如果是jsonp url上会拼接callback=？（默认是callback，当然如果参数上有 jsonp：’jsoncallback’，那么url会拼接jsoncallback=？ 总之callback=？是核心 ） 二。然后把callback的值(如:jQuery1236827957501 这个是jquery和随机数拼接在一起的 jquery源码可见)传给服务器。 expando: &quot;jQuery&quot; + (g.fn.jquery + Math.random()).replace(/\D/g, &quot;&quot;), 。。。 var e = qn.apop() || g.expando + &quot;_&quot; + Mn++; 注意：服务端得到callback的数值后，要用jQuery1236827957501(……)把将要输出的json内容包括起来，此时，服务器生成 json 数据才能被客户端正确接收。 三.然后以 javascript 语法的方式，生成一个function， function 名字就是传递上来的参数 ‘jsoncallback’的值 jQuery1236827957501 .最后将 json 数据直接以入参的方式，放置到 function 中，这样就生成了一段 js 语法的文档，返回给客户端。 jQuery1800931218545883894_1463990648558({&quot;threelocal&quot;:[{&quot;cate&quot;:&quot;A&quot;,&quot;catelist&quot;:[{&quot;listname&quot;:&quot;anzhenqiao&quot;,&quot;localname&quot;:&quot;安贞&quot;,&quot;id&quot;:1204,&quot;clickcode&quot;。。。 四.客户端浏览器，解析script标签，并执行返回的 javascript 文档，此时javascript文档数据，作为参数， 传入到了客户端预先定义好的 callback 函数(如上例中jquery $.ajax()方法封装的的success: function (json) )里。可以理解成带有参数的函数调用 总结：可以说jsonp的方式原理上和是一致的(qq空间就是大量采用这种方式来实现跨域数据交换的)。JSONP是一种脚本注入(Script Injection)行为，所以有一定的安全隐患。 var eleScript= document.createElement(&quot;script&quot;); eleScript.type = &quot;text/javascript&quot;; eleScript.src = &quot;http://example2.com/getinfo.php&quot;; document.getElementsByTagName(&quot;HEAD&quot;)[0].appendChild(eleScript) 实质的调用形式 其实如下例子 &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt; &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; &gt; &lt;head&gt; &lt;title&gt;Test Jsonp&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function jsonpCallback(result) { alert(result.msg); } &lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://crossdomain.com/jsonServerResponse?jsonp=jsonpCallback&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[css3]]></title>
      <url>http://yoursite.com/2016/10/20/css3/</url>
      <content type="text"><![CDATA[介绍各种关于css和css3相关属性的使用 backgroundbackground-imagebackground-image 可以放置多张图片 background-size 设置图片的大小100%图片原尺寸 20%图片原尺寸的20% contain 以区域最短的宽（或高）为准，成比例填充 cover 图片覆盖整个背景区域 background-clip 决定显示背景图片的哪部分 padding-box 显示内边距以内的背景 border-box 显示边框以内的背景 content-box 显示内容区域的背景 background-origin： 决定背景图片怎么放置 border-box 边框以内 开始放置 padding-box 内边距以内开始放置 content-box 内容区域开始放置 background-position：同-origin 一个原理 ，只是具体定位背景图片从哪开始放置 background-color：background-color:设置背景的图片 background-repeat：background-repeat：设置背景图片是否重复铺设 background-attchment：background-attachment: scroll|fixed|local|initial|inherit; 设备像素比devicePixelRatio简单介绍定义如下：window.devicePixelRatio是设备上物理像素和设备独立像素(device-independent pixels (dips))的比例。公式表示就是：window.devicePixelRatio = 物理像素 / dips dip或dp,（device independent pixels，设备独立像素）与屏幕密度有关。dip可以用来辅助区分视网膜设备还是非视网膜设备。 所有非视网膜屏幕的iphone在垂直的时候，宽度为320物理像素。当你使用的时候，会设置视窗布局宽度（不同于视觉区域宽度，不放大显示情况下，两者大小一致，见下图）为320px, 于是，页面很自然地覆盖在屏幕上。 这样，非视网膜屏幕的iphone上，屏幕物理像素320像素，独立像素也是320像素，因此，window.devicePixelRatio等于1. 而对于视网膜屏幕的iphone，如iphone4s, 纵向显示的时候，屏幕物理像素640像素。同样，当用户设置的时候，其视区宽度并不是640像素，而是320像素，这是为了有更好的阅读体验 – 更合适的文字大小。 这样，在视网膜屏幕的iphone上，屏幕物理像素640像素，独立像素还是320像素，因此，window.devicePixelRatio等于2. 说明case1 ：对于苹果电脑是视网膜屏幕，图片常常看起来模糊，需要适配2x，利用css3新样式，可以做到，但低版本的兼容性较差 .logo{ background:url(images/icon.png); } @media only screen and (-webkit-min-device-pixel-ratio:2), only screen and (min-device-pixel-ratio:2) { .logo{ background:url(images/icon_2x.png); } } box-sizingMath Math.random() 0.0-1.0 随机数 Math.ceil() 向上取整 Math.floor() 一律舍去 仅保留整数 Math.round() 进行四舍五入]]></content>
    </entry>

    
  
  
</search>
